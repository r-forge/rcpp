\documentclass[10pt]{article}
%\VignetteIndexEntry{RcppGSL}

\usepackage{url}
\usepackage[colorlinks]{hyperref}
\setlength{\oddsidemargin}{0pt}
\setlength{\textwidth}{17cm} % uh-oh, I use letter :)
\usepackage[authoryear,round,longnamesfirst]{natbib}

<<echo=FALSE,print=FALSE>>=
library( "RcppGSL" )
options("width"=65)
rcppgsl.version <- packageDescription( "RcppGSL" )$Version
prettyDate <- format(Sys.Date(), "%B %e, %Y")
@
% closing $ needed here


\usepackage[colorlinks]{hyperref}
\author{Dirk Eddelbuettel \and Romain Fran\c{c}ois}
\title{RcppGSL}
\date{Version \Sexpr{rcppgsl.version} as of \Sexpr{prettyDate}}

\begin{document}
\maketitle

\abstract{
  \noindent
  The GNU Scientific Library \texttt{GSL} is a numerical library for
  C and C++ programmers. It is free software under the GNU General Public License.
  The library provides a wide range of mathematical routines such as random number
  generators, special functions and least-squares fitting.
  There are over 1000 functions in total with an extensive test suite.

  The \texttt{RcppGSL} package provides an easy-to-use interface
  between \texttt{GSL} data structures and concepts from \texttt{Rcpp}
  \citep{CRAN:Rcpp} which is itself a package that eases the interfaces
  between R and C++.
}

\section{Introduction}

TODO

\section{Motivation: FastLm}

TODO: Show FastLm() to show what this can be used for.

\section{Vectors}

\subsection{GSL Vectors}

\texttt{GSL} defines various vector types to manipulate one-dimensionnal
data, similar to R arrays. For example the \verb|gsl_vector| and \verb|gsl_vector_int|
structs are defined as:

<<lang=cpp>>=
typedef struct{
  size_t size;
  size_t stride;
  double * data;
  gsl_block * block;
  int owner;
} gsl_vector;

typedef struct {
  size_t size;
  size_t stride;
  int *data;
  gsl_block_int *block;
  int owner;
}
gsl_vector_int;
@

A typical use of the \verb|gsl_vector| struct is given below:

<<lang=cpp>>=
int i;

// allocate a gsl_vector of size 3
gsl_vector * v = gsl_vector_alloc (3);

// fill the vector
for (i = 0; i < 3; i++) {
  gsl_vector_set (v, i, 1.23 + i);
}

// access elements
double sum = 0.0 ;
for (i = 0; i < 3; i++) {
	 sum += gsl_vector_set( v, i ) ;
}

// free the memory
gsl_vector_free (v);
@

\subsection{RcppGSL::vector}

\texttt{RcppGSL} defines the template \texttt{RcppGSL::vector<T>} to manipulate
\verb|gsl_vector| pointers taking advantage of C++ templates. Using the
template the previous example becomes:

<<lang=cpp>>=
int i;

// allocate a gsl_vector of size 3
RcppGSL::vector<double> v(3);

// fill the vector
for (i = 0; i < 3; i++) {
  v[i] = 1.23 + i ;
}

// access elements
double sum = 0.0 ;
for (i = 0; i < 3; i++) {
	 sum += v[i] ;
}

// free the memory
v.free() ;
@

The class \texttt{RcppGSL::vector<double>} is a smart pointer, that can be used
anywhere where a raw pointer \verb|gsl_vector| can be used, such as the
\verb|gsl_vector_set| and \verb|gsl_vector_get| functions above.

Beyond the convenience of a nicer syntax for allocation and release of memory,
the \texttt{RcppGSL::vector} template faciliates interchange of \texttt{GSL}
vectors with \texttt{Rcpp} concepts. The following example defines a \texttt{.Call}
compatible function called \verb|sum_gsl_vector_int|
that operates on a \verb|gsl_vector_int| through the \texttt{RcppGSL::vector<int>}
template specialization:

<<lang=cpp>>=
RCPP_FUNCTION_1( int, sum_gsl_vector_int, RcppGSL::vector<int> vec){
  int n = vec.size() ;
  int res = std::accumulate( vec.begin(), vec.end(), 0 ) ;
  vec.free() ;
  return res ;
}
@

The function can then simply be called from R :

<<>>=
.Call( "sum_gsl_vector_int", 1:10 )
@

A second example shows a simple function that grabs elements of an
R list as \verb|gsl_vector| objects using implicit conversion mechanisms
of Rcpp

<<lang=cpp>>=
RCPP_FUNCTION_1( double, gsl_vector_sum_2, Rcpp::List data ){
  // grab "x" as a gsl_vector through
  // the RcppGSL::vector<double> class
  RcppGSL::vector<double> x = data["x"] ;

  // grab "y" as a gsl_vector through
  // the RcppGSL::vector<int> class
  RcppGSL::vector<int> y = data["y"] ;
  double res = 0.0 ;
  for( int i=0; i< x->size; i++){
    res += x[i] * y[i] ;
  }

  // as usual with GSL, we need to explicitely free the
  // memory
  x.free() ;
  y.free() ;

  // return the result
  return res ;
}
@

called from R :

<<eval=FALSE>>=
data <- list( x = seq(0,1,length=10), y = 1:10 )
.Call( "gsl_vector_sum_2", data )
@


\subsection{Mapping}

\begin{table}
\centering
\begin{small}
\begin{tabular}{ll}
\hline
gsl vector & RcppGSL \\
\hline
\texttt{gsl\_vector} & \texttt{RcppGSL::vector<double>} \\
\texttt{gsl\_vector\_int} & 	\texttt{RcppGSL::vector<int>} \\
\texttt{gsl\_vector\_float} & 	\texttt{RcppGSL::vector<float>} \\
\texttt{gsl\_vector\_long} & 	\texttt{RcppGSL::vector<long>} \\
\texttt{gsl\_vector\_char} & 	\texttt{RcppGSL::vector<char>} \\
\texttt{gsl\_vector\_complex} & 	\texttt{RcppGSL::vector<gsl\_complex>} \\
\texttt{gsl\_vector\_complex\_float} & \texttt{RcppGSL::vector<gsl\_complex\_float>} \\
\texttt{gsl\_vector\_complex\_long\_double} & 	\texttt{RcppGSL::vector<gsl\_complex\_long\_double>} \\
\texttt{gsl\_vector\_long\_double} & 	\texttt{RcppGSL::vector<long double>} \\
\texttt{gsl\_vector\_short} & 	\texttt{RcppGSL::vector<short>} \\
\texttt{gsl\_vector\_uchar} & 	\texttt{RcppGSL::vector<unsigned char>} \\
\texttt{gsl\_vector\_uint} & 	\texttt{RcppGSL::vector<unsigned int>} \\
\texttt{gsl\_vector\_ushort} & 	\texttt{RcppGSL::vector<insigned short>} \\
\texttt{gsl\_vector\_ulong} & 	\texttt{RcppGSL::vector<unsigned long>} \\

\hline
\end{tabular}
\end{small}
\caption{Correspondance between GSL vector types and templates defined
in RcppGSL.}
\end{table}

\section{ Vector Views}

Several \texttt{GSL} algorithms return GSL vector views as result. \texttt{RcppGSL}
defines the template class \texttt{RcppGSL::vector\_view} to handle
vector views using C++ syntax.

<<lang=cpp>>=
extern "C" SEXP test_gsl_vector_view(){
  int n = 10 ;
  RcppGSL::vector<double> v(n) ;
  for( int i=0 ; i<n; i++){
    v[i] = i ;
  }
  RcppGSL::vector_view<double> v_even = gsl_vector_subvector_with_stride(v, 0, 2, n/2);
  RcppGSL::vector_view<double> v_odd  = gsl_vector_subvector_with_stride(v, 1, 2, n/2);

  List res = List::create(
    _["even"] = v_even,
    _["odd" ] = v_odd
    ) ;
  v.free() ;

  return res ;
}
@

As with vectors, c++ objects \texttt{RcppGSL::vector\_view} can be implicitely
converted to their associated gsl view type, as listed in table \ref{tabviews}
so that they can be passed to compatible gsl algorithms.

\begin{table}
\centering
\begin{small}
\begin{tabular}{ll}
\hline
gsl vector views & RcppGSL \\
\hline
\texttt{gsl\_vector\_view} & \texttt{RcppGSL::vector\_view<double>} \\
\texttt{gsl\_vector\_view\_int} & 	\texttt{RcppGSL::vector\_view<int>} \\
\texttt{gsl\_vector\_view\_float} & 	\texttt{RcppGSL::vector\_view<float>} \\
\texttt{gsl\_vector\_view\_long} & 	\texttt{RcppGSL::vector\_view<long>} \\
\texttt{gsl\_vector\_view\_char} & 	\texttt{RcppGSL::vector\_view<char>} \\
\texttt{gsl\_vector\_view\_complex} & 	\texttt{RcppGSL::vector\_view<gsl\_complex>} \\
\texttt{gsl\_vector\_view\_complex\_float} & \texttt{RcppGSL::vector\_view<gsl\_complex\_float>} \\
\texttt{gsl\_vector\_view\_complex\_long\_double} & 	\texttt{RcppGSL::vector\_view<gsl\_complex\_long\_double>} \\
\texttt{gsl\_vector\_view\_long\_double} & 	\texttt{RcppGSL::vector\_view<long double>} \\
\texttt{gsl\_vector\_view\_short} & 	\texttt{RcppGSL::vector\_view<short>} \\
\texttt{gsl\_vector\_view\_uchar} & 	\texttt{RcppGSL::vector\_view<unsigned char>} \\
\texttt{gsl\_vector\_view\_uint} & 	\texttt{RcppGSL::vector\_view<unsigned int>} \\
\texttt{gsl\_vector\_view\_ushort} & 	\texttt{RcppGSL::vector\_view<insigned short>} \\
\texttt{gsl\_vector\_view\_ulong} & 	\texttt{RcppGSL::vector\_view<unsigned long>} \\

\hline
\end{tabular}
\end{small}
\caption{\label{tabviews}Correspondance between GSL vector view types and templates defined
in RcppGSL.}
\end{table}


\section{Matrices}

TODO: write content about \texttt{RcppGSL::matrix} and \texttt{RcppGSL::matrix\_view}


\section{References}

\bibliographystyle{abbrvnat}
\bibliography{RcppGSL}

\end{document}

