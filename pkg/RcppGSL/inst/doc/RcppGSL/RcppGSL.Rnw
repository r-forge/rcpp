\documentclass[10pt]{article}
%\VignetteIndexEntry{RcppGSL}

\usepackage{url,color}
\usepackage[authoryear,round,longnamesfirst]{natbib}
\usepackage[colorlinks]{hyperref}
\definecolor{link}{rgb}{0,0,0.3}	%% next few lines courtesy of RJournal.sty
\hypersetup{
    colorlinks,%
    citecolor=link,%
    filecolor=link,%
    linkcolor=link,%
    urlcolor=link
}
\usepackage{vmargin}
\setmargrb{0.75in}{0.75in}{0.75in}{0.75in}

\newcommand{\proglang}[1]{\textsf{#1}}
\newcommand{\pkg}[1]{{\fontseries{b}\selectfont #1}}

<<echo=FALSE,print=FALSE>>=
library( "RcppGSL" )
options("width"=65)
rcppgsl.version <- packageDescription( "RcppGSL" )$Version
prettyDate <- format(Sys.Date(), "%B %e, %Y")
@
% closing $ needed here

\author{Dirk Eddelbuettel \and Romain Fran\c{c}ois}
\title{\pkg{RcppGSL}: Easier \pkg{GSL} use from \proglang{R} via \pkg{Rcpp}}
\date{Version \Sexpr{rcppgsl.version} as of \Sexpr{prettyDate}}

\begin{document}
\maketitle

\abstract{
  \shortcites{GSL} %% so that we get Galassi et al instead of all names
  \noindent
  The GNU Scientific Library, or \pkg{GSL}, is a collection of numerical
  routines for scientifc computing \citep{GSL}. It is particularly useful for
  \proglang{C} and \proglang{C++} programs as it provides a standard
  \proglang{C} interface to a wide range of mathematical routines such as
  special functions, permutations, combinations, fast fourier transforms,
  eigensystems, random numbers, quadrature, random distributions,
  quasi-random sequences, Monte Carlo integration, N-tuples, differential
  equations, simulated annealing, numerical differentiation, interpolation,
  series acceleration, Chebyshev approximations, root-finding, discrete
  Hankel transforms physical constants, basis splines and wavelets.  There
  are over 1000 functions in total with an extensive test suite.

  The \pkg{RcppGSL} package provides an easy-to-use interface between
  \pkg{GSL} data structures and \proglang{R} using concepts from \pkg{Rcpp}
  \citep{CRAN:Rcpp} which is itself a package that eases the interfaces
  between \proglang{R} and C++.
}

\section{Introduction}

The GNU Scientific Library, or \pkg{GSL}, is a collection of numerical
routines for scientifc computing \citep{GSL}. It is a rigourously developed
and tested library providing support for a wide range of scientific or
numerical tasks. Among the topics covered in the GSL are
%% from the GSL manual
complex numbers, roots of polynomials,
special functions, vector and matrix data structures,
permutations, combinations, sorting, BLAS support,
linear algebra, fast fourier transforms, eigensystems,
random numbers,	quadrature, random distributions, quasi-random sequences,
Monte Carlo integration, N-tuples,
differential equations,	simulated annealing,
numerical differentiation, interpolation,
series acceleration, Chebyshev approximations,
root-finding, discrete Hankel transforms
least-squares fitting,	minimization,
physical constants, basis splines and wavelets.

Support for \proglang{C} programming with the GSL is readily available: the GSL itself is written in \proglang{C}
and provides a \proglang{C}-language Application Programming Interface
(API). Access from \proglang{C++} is therefore possible, albeit not at the
abstraction level that can be offered by dedicated \proglang{C++}
implementations.\footnote{Several \proglang{C++} wrappers for the GSL have
  been written over the years yet none reached a state of completion
  comparable to the GSL itself. Three such wrapping library are
  \url{http://cholm.home.cern.ch/cholm/misc/gslmm/},
  \url{http://gslwrap.sourceforge.net/} and
  \url{http://code.google.com/p/gslcpp/}.}

The GSL is somewhat unique among numerical libraries. Its combination of
broad coverage of scientific topics, serious implementation effort and the
use of a FLOSS license have lead to a fairly wide usage of the library.  As a
concrete example, we can consider the the CRAN repository network for the
\proglang{R} language and environment \citep{R:Main}.  CRAN contains over a
dozen packages interfacing the GSL: \pkg{copula}, \pkg{dynamo}, \pkg{gsl},
\pkg{gstat}, \pkg{magnets}, \pkg{mvabund}, \pkg{QRMlib}, \pkg{RBrownie},
\pkg{RDieHarder}, \pkg{RHmm}, \pkg{segclust}, \pkg{surveillance}, and
\pkg{topicmodels}.  This is a clear indication that the GSL is popular among
programmers using either the \proglang{C} or \proglang{C++} language for
solving problems applied science.

At the same time, the \pkg{Rcpp} package \citep{CRAN:Rcpp} offers a
higher-level abstraction between \proglang{R} and underlying \proglang{C++}
(or \proglang{C}) code.  \pkg{Rcpp} permits \proglang{R} objects like
vectors, matrices, lists, functions, environments, $\ldots$, to be
manipulated directly at the \proglang{C++} level, alleviates the needs for
complicated and error-prone parameter passing and memory allocation. It also
permits compact vectorised expressions similar to what can be written in
\proglang{R} directly at the \proglang{C++} level.

The \pkg{RcppGSL} package discussed here aims the help close the gap. It
tries to offer access to GSL functions, in particular via the vector and
matrix data structures used throughout the GSL, while staying closer to the
`whole object model' familar to the \proglang{R} programmer.

The rest of paper is organised as follows. The next section shows a
motivating example of a fast linear model fit routine using \pkg{GSL} functions.
The following section discusses support for \pkg{GSL} vector types, which is
followed by a section on matrices.

\section{Motivation: FastLm}

TODO: Show FastLm() to show what this can be used for.

\section{Vectors}

\subsection{GSL Vectors}

\pkg{GSL} defines various vector types to manipulate one-dimensionnal
data, similar to \proglang{R} arrays. For example the \verb|gsl_vector| and \verb|gsl_vector_int|
structs are defined as:

<<lang=cpp>>=
typedef struct{
  size_t size;
  size_t stride;
  double * data;
  gsl_block * block;
  int owner;
} gsl_vector;

typedef struct {
  size_t size;
  size_t stride;
  int *data;
  gsl_block_int *block;
  int owner;
}
gsl_vector_int;
@

A typical use of the \verb|gsl_vector| struct is given below:

<<lang=cpp>>=
int i;

// allocate a gsl_vector of size 3
gsl_vector * v = gsl_vector_alloc (3);

// fill the vector
for (i = 0; i < 3; i++) {
  gsl_vector_set (v, i, 1.23 + i);
}

// access elements
double sum = 0.0 ;
for (i = 0; i < 3; i++) {
	 sum += gsl_vector_set( v, i ) ;
}

// free the memory
gsl_vector_free (v);
@

\subsection{RcppGSL::vector}

\pkg{RcppGSL} defines the template \texttt{RcppGSL::vector<T>} to manipulate
\verb|gsl_vector| pointers taking advantage of C++ templates. Using the
template the previous example becomes:

<<lang=cpp>>=
int i;

// allocate a gsl_vector of size 3
RcppGSL::vector<double> v(3);

// fill the vector
for (i = 0; i < 3; i++) {
  v[i] = 1.23 + i ;
}

// access elements
double sum = 0.0 ;
for (i = 0; i < 3; i++) {
	 sum += v[i] ;
}

// free the memory
v.free() ;
@

The class \texttt{RcppGSL::vector<double>} is a smart pointer, that can be used
anywhere where a raw pointer \verb|gsl_vector| can be used, such as the
\verb|gsl_vector_set| and \verb|gsl_vector_get| functions above.

Beyond the convenience of a nicer syntax for allocation and release of memory,
the \texttt{RcppGSL::vector} template faciliates interchange of \pkg{GSL}
vectors with \pkg{Rcpp} concepts. The following example defines a \texttt{.Call}
compatible function called \verb|sum_gsl_vector_int|
that operates on a \verb|gsl_vector_int| through the \texttt{RcppGSL::vector<int>}
template specialization:

<<lang=cpp>>=
RCPP_FUNCTION_1( int, sum_gsl_vector_int, RcppGSL::vector<int> vec){
  int res = std::accumulate( vec.begin(), vec.end(), 0 ) ;
  vec.free() ;
  return res ;
}
@

The function can then simply be called from \proglang{R} :

<<>>=
.Call( "sum_gsl_vector_int", 1:10 )
@

A second example shows a simple function that grabs elements of an
R list as \verb|gsl_vector| objects using implicit conversion mechanisms
of \pkg{Rcpp}

<<lang=cpp>>=
RCPP_FUNCTION_1( double, gsl_vector_sum_2, Rcpp::List data ){
  // grab "x" as a gsl_vector through
  // the RcppGSL::vector<double> class
  RcppGSL::vector<double> x = data["x"] ;

  // grab "y" as a gsl_vector through
  // the RcppGSL::vector<int> class
  RcppGSL::vector<int> y = data["y"] ;
  double res = 0.0 ;
  for( size_t i=0; i< x->size; i++){
    res += x[i] * y[i] ;
  }

  // as usual with GSL, we need to explicitely free the
  // memory
  x.free() ;
  y.free() ;

  // return the result
  return res ;
}
@

called from \proglang{R} :

<<>>=
data <- list( x = seq(0,1,length=10), y = 1:10 )
.Call( "gsl_vector_sum_2", data )
@


\subsection{Mapping}

\begin{table}
\centering
\begin{small}
\begin{tabular}{ll}
\hline
gsl vector & RcppGSL \\
\hline
\texttt{gsl\_vector} & \texttt{RcppGSL::vector<double>} \\
\texttt{gsl\_vector\_int} & 	\texttt{RcppGSL::vector<int>} \\
\texttt{gsl\_vector\_float} & 	\texttt{RcppGSL::vector<float>} \\
\texttt{gsl\_vector\_long} & 	\texttt{RcppGSL::vector<long>} \\
\texttt{gsl\_vector\_char} & 	\texttt{RcppGSL::vector<char>} \\
\texttt{gsl\_vector\_complex} & 	\texttt{RcppGSL::vector<gsl\_complex>} \\
\texttt{gsl\_vector\_complex\_float} & \texttt{RcppGSL::vector<gsl\_complex\_float>} \\
\texttt{gsl\_vector\_complex\_long\_double} & 	\texttt{RcppGSL::vector<gsl\_complex\_long\_double>} \\
\texttt{gsl\_vector\_long\_double} & 	\texttt{RcppGSL::vector<long double>} \\
\texttt{gsl\_vector\_short} & 	\texttt{RcppGSL::vector<short>} \\
\texttt{gsl\_vector\_uchar} & 	\texttt{RcppGSL::vector<unsigned char>} \\
\texttt{gsl\_vector\_uint} & 	\texttt{RcppGSL::vector<unsigned int>} \\
\texttt{gsl\_vector\_ushort} & 	\texttt{RcppGSL::vector<insigned short>} \\
\texttt{gsl\_vector\_ulong} & 	\texttt{RcppGSL::vector<unsigned long>} \\

\hline
\end{tabular}
\end{small}
\caption{Correspondance between \pkg{GSL} vector types and templates defined
in \pkg{RcppGSL}.}
\end{table}

\subsection{ Vector Views}

Several \pkg{GSL} algorithms return \pkg{GSL} vector views as result. \pkg{RcppGSL}
defines the template class \texttt{RcppGSL::vector\_view} to handle
vector views using C++ syntax.

<<lang=cpp>>=
extern "C" SEXP test_gsl_vector_view(){
  int n = 10 ;
  RcppGSL::vector<double> v(n) ;
  for( int i=0 ; i<n; i++){
    v[i] = i ;
  }
  RcppGSL::vector_view<double> v_even = gsl_vector_subvector_with_stride(v, 0, 2, n/2);
  RcppGSL::vector_view<double> v_odd  = gsl_vector_subvector_with_stride(v, 1, 2, n/2);

  List res = List::create(
    _["even"] = v_even,
    _["odd" ] = v_odd
    ) ;
  // we only need to free v, the views don t own data
  v.free() ;

  return res ;
}
@

As with vectors, c++ objects \texttt{RcppGSL::vector\_view} can be implicitely
converted to their associated gsl view type, as listed in table \ref{tabviews}
so that they can be passed to compatible gsl algorithms.

\begin{table}
\centering
\begin{small}
\begin{tabular}{ll}
\hline
gsl vector views & RcppGSL \\
\hline
\texttt{gsl\_vector\_view} & \texttt{RcppGSL::vector\_view<double>} \\
\texttt{gsl\_vector\_view\_int} & 	\texttt{RcppGSL::vector\_view<int>} \\
\texttt{gsl\_vector\_view\_float} & 	\texttt{RcppGSL::vector\_view<float>} \\
\texttt{gsl\_vector\_view\_long} & 	\texttt{RcppGSL::vector\_view<long>} \\
\texttt{gsl\_vector\_view\_char} & 	\texttt{RcppGSL::vector\_view<char>} \\
\texttt{gsl\_vector\_view\_complex} & 	\texttt{RcppGSL::vector\_view<gsl\_complex>} \\
\texttt{gsl\_vector\_view\_complex\_float} & \texttt{RcppGSL::vector\_view<gsl\_complex\_float>} \\
\texttt{gsl\_vector\_view\_complex\_long\_double} & 	\texttt{RcppGSL::vector\_view<gsl\_complex\_long\_double>} \\
\texttt{gsl\_vector\_view\_long\_double} & 	\texttt{RcppGSL::vector\_view<long double>} \\
\texttt{gsl\_vector\_view\_short} & 	\texttt{RcppGSL::vector\_view<short>} \\
\texttt{gsl\_vector\_view\_uchar} & 	\texttt{RcppGSL::vector\_view<unsigned char>} \\
\texttt{gsl\_vector\_view\_uint} & 	\texttt{RcppGSL::vector\_view<unsigned int>} \\
\texttt{gsl\_vector\_view\_ushort} & 	\texttt{RcppGSL::vector\_view<insigned short>} \\
\texttt{gsl\_vector\_view\_ulong} & 	\texttt{RcppGSL::vector\_view<unsigned long>} \\

\hline
\end{tabular}
\end{small}
\caption{\label{tabviews}Correspondance between \pkg{GSL} vector view types and templates defined
in \pkg{RcppGSL}.}
\end{table}

\section{Matrices}

\texttt{GSL} defines a set of matrix data types : \texttt{gsl\_matrix},
\texttt{gsl\_matrix\_int} etc ... for which \pkg{RcppGSL} also defines
convenience \proglang{C++} wrapper generated by the \texttt{RcppGSL::matrix}
template.

\subsection{creating matrices}

The \texttt{RcppGSL::matrix} template exposes three constructors.

<<lang=cpp>>=
// convert an R matrix to a GSL matrix
matrix( SEXP x) throw(::Rcpp::not_compatible)

// encapsulate a GSL matrix pointer
matrix( gsl_matrix* x)

// create a new matrix with the given number of rows and columns
matrix( int nrow, int ncol)
@

\subsection{implicit conversion}

\texttt{RcppGSL::matrix} defines implicit conversion to a pointer to
the associated GSL matrix type, as well as dereferencing operators, making
the class \texttt{RcppGSL::matrix} look and feel like a pointer to a GSL
matrix type.

<<lang=cpp>>=
	gsltype* data ;
	operator gsltype*(){ return data ; }
	gsltype* operator->() const { return data; }
	gsltype& operator*() const { return *data; }
@

\subsection{indexing}

Indexing of GSL matrices is usually the task of the functions
\texttt{gsl\_matrix\_get}, \texttt{gsl\_matrix\_int\_get}, ... and
\texttt{gsl\_matrix\_set}, \texttt{gsl\_matrix\_int\_set}, ...

\pkg{RcppGSL} takes advantage of both operator overloading and templates
to make indexing a GSL matrix much more convenient.

<<lang=cpp>>=
// create a matrix of size 10x10
RcppGSL::matrix<int> mat(10,10) ;

// fill the diagonal
for( int i=0; i<10: i++){
	mat(i,i) = i ;
}
@

\subsection{Methods}

The \texttt{RcppGSL::matrix} type also defines :
\begin{itemize}
\item nrow : extract the number of rows
\item ncol : extract the number of columns
\item size : extract the number of elements
\item free : release the memory
\end{itemize}


\section{References}

\bibliographystyle{plainnat}
\bibliography{RcppGSL}

\end{document}

