%% use JSS class but for now with nojss option
\documentclass[nojss,shortnames,article]{jss}
\usepackage{rotating}
\usepackage{float}
\usepackage{booktabs}

\author{Dirk Eddelbuettel\\Debian Project} % \And Second Author\\Plus Affiliation}
\title{From \pkg{DEoptim} to \pkg{RcppDE}: \\
  A case study in porting from \proglang{C} to \proglang{C++} \\
  using \pkg{Rcpp} and \pkg{RcppArmadillo}}

\Plainauthor{Dirk Eddelbuettel} % , Second Author} %% comma-separated
\Plaintitle{DEoptim: A case study in porting to C++ and Rcpp}
\Shorttitle{A case study in porting to C++ and Rcpp}

\Abstract{
  \noindent
  \pkg{DEoptim} \citep{MullenArdiaEtAl:2009:DEoptim,ArdiaBoudtCarlEtAl:2010:DEoptim,CRAN:DEoptim}
  provides differential evolution optimisation for 
  \proglang{R}.  It is based on an implementation by Storn
  \citep{PriceStornLampinen:2006:DE} and was originally implemented as an
  interpreted \proglang{R} script. It was then rewritten in ANSI C which
  resulted in a much improved performance.

  The present paper introduces another implementation. This version is
  written in \proglang{C++} based on the \pkg{Rcpp} package \citep{CRAN:Rcpp}
  which provides tools for a more direct integration of \proglang{R} objects at the \proglang{C++}
  level---and vice versa. It also uses the \pkg{RcppArmadillo} package \citep{CRAN:RcppArmadillo}
  which provides an interface from \proglang{R} to the \pkg{Armadillo} linear algebra
  package written in \proglang{C++} by Sanderson \citep{Sanderson:2010:Armadillo}.
}

\Keywords{\pkg{Rcpp}, \pkg{RcppArmadillo}, \pkg{DEoptim}, differential
  evolution, genetic algorithm} %% at least one keyword must be supplied
\Plainkeywords{Rcpp, RcppArmadillo, DEoptim, differential evolution, genetic algorith} %% without formatting

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

\Address{
  Dirk Eddelbuettel \\
  Debian Project \\
  River Forest, IL, USA\\
  %% Telephone: +43/1/31336-5053
  %% Fax: +43/1/31336-734
  E-mail: \email{edd@debian.org}\\
  URL: \url{http://dirk.eddelbuettel.com}
}

%% need no \usepackage{Sweave.sty}

% ------------------------------------------------------------------------

\begin{document}

\section{Introduction}

\pkg{DEoptim}
\citep{MullenArdiaEtAl:2009:DEoptim,ArdiaBoudtCarlEtAl:2010:DEoptim,CRAN:DEoptim}
provides differential evolution optimisation for the \proglang{R} language
and statistical environement.  Differential optimisation is one of several
evolutionary computing approaches; genetic algorithns and simulated annealing
are two other ones.  Differential optimisation is reasonably close to genetic
algorithms but differs in one key aspect: parameter values are encoded as
floating point values (rather than sequences of binary digits) which makes it
particular suitable for real-valued optimisation problems.

\pkg{DEoptim} is based on an implementation by Storn
\citep{PriceStornLampinen:2006:DE}. It was originally implemented as an
(interpreted) \proglang{R} script before being rewritten in (compiled)
\proglang{C} which resulted in a much improved performance. \pkg{DEoptim} is
being used to optimise problems from a wide range of problem domains ranging
from crystallography \citep{MullenKrayzmanLevin:2010:Atomic} to agricultural
economics \citep{BoernerHigginsKantelhardt:2007:Rainfall} and computational
finance \citep{BoudtPetersonCarl:2008:HFPortfolio}. It is also being by two
other CRAN packages for R: \pkg{micEconCES} \citep{CRAN:micEconCES} and
\pkg{selectMeta} \citep{CRAN:selectMeta}.

The present paper introduces the \proglang{R} package \pkg{RcppDE}. It
provides another iteration as far as implementations of differential
evolution go. This new version is based very closely on \pkg{DEoptim} but
written in \proglang{C++}. The implementation employs the \pkg{Rcpp} package
\citep{CRAN:Rcpp} which provides tools for a more direct integration of
\proglang{R} objects at the \proglang{C++} level---and vice versa. It also
uses the \pkg{RcppArmadillo} package \citep{CRAN:RcppArmadillo} which
provides an interface from \proglang{R} to the \pkg{Armadillo} linear algebra
package written in \proglang{C++} by Sanderson
\citep{Sanderson:2010:Armadillo}.

The code structure descends directly from the current \pkg{DEoptim} by
\cite{CRAN:DEoptim}.  The conversion to \proglang{C++} was undertaken to see
whether one or more of the goals \textsl{shorter}, \textsl{easier}  and
\textsl{faster} could be achieved by switching the implementation
language. These goals were loosely defined as follows:
\begin{itemize}
\item[shorter] replacing code that is by necessity somewhat verbose when
  written in \proglang{C} with more compact code written in \proglang{C++}:
  an example would be copying of a matrix which is implemented as a dual loop
  copying each element --- whereas \proglang{C++} allows us to use a single
  (overloaded) \verb|+| operator and hence a single statement;
\item[easier] this is a corollary to the previous point but also covers
  aspect as the automatic type conversion offered by \pkg{Rcpp} as well as
  the automatic memory management: by replacing allocation and freeing of
  heap-based dynamic memory, a conistent source of programmer error would be
  elimnated; 
\item[faster] this was a bit more of a conjecture as ultimately,
  \proglang{C++} and \proglang{C} can be expected to be roughly equivalent
  given matching compiler versions etc; however gains maybe be expected from
  replacing a copying operation of block of adjacent memory cells with a
  single \verb|memcpy()| call done behind the scenes; \pkg{RcppArmadillo}
  also offers further possible gains from template metaprogramming which can
  result in the elimination of temporary object in complex expression where,
  loosely speaking, compile-time effort is substituted to gain later run-time
  performance. 
\end{itemize}

This paper is organised as follows. The next sections describes the structure
of \pkg{DEoptim} which \pkg{RcppDE} shadows closesly. The following twp
section compares differences at the \proglang{R} and \proglang{C++} level,
respectively. Next, we changes in auxiliarry files are discusses before a
short section reviews perfomance changes. A summary concludes. The
appendix contains a list of figures contrasting the two implementations.

\section[DEoptim structure]{\pkg{DEoptim} structure}

\pkg{DEoptim} is a straightforward and well-implemented package. Its
functionality is provided by three \proglang{R} files, as well as three
\proglang{C} files.

Table~\ref{tab:Rfiles} lists the files and corresponding key functions:

\begin{table}[htb]
  \begin{center}
    \begin{tabular}{lr}
      \toprule
      File                                          & Functions \\ 
%                                                    \cmidrule{2}
      \verb|DEoptim.R| \phantom{XXXXXXXXX}        & \verb|DEoptim()| \\
                                                   & \verb|DEoptim.control()| \\[6pt]
      \verb|methods.R|                            & \verb|summary.DEoptim()| \\
                                                   & \verb|plot.DEoptim()| \\[6pt]
      \verb|zzz.R|                                & \verb|.onLoad()| \\
      \bottomrule
    \end{tabular}
    \caption{Source file organisation for \proglang{R} files in \pkg{DEoptim}
    and \pkg{RcppDE}}
    \label{tab:Rfiles}
  \end{center}
\end{table}

Very few changes has to made for \pkg{RcppDE} as keeping the interface
compatible was an important goal. As can be seen from table~\ref{tab:Rfiles},
no files or functions were added.  A more detailed comparison follow below
in section~\ref{sec:Rchanges}.

Similarly, table~\ref{tab:Cfiles} lists the \proglang{C} and \proglang{C++}
files in \pkg{DEoptim} and \pkg{RcppDE}, respectively:

\begin{table}[htb]
  \begin{center}
    \begin{tabular}{lrclr}
      \toprule
      \multicolumn{2}{c}{\pkg{DEoptim}} & & \multicolumn{2}{c}{\pkg{RcppDE}} \\
      File  & Functions    & & File  & Functions\\ 
      %                      \cmidrule{1-2,3-4} \\
      \midrule 
      \verb|de4_0.c| & \verb|DEoptimC()| & & \verb|deoptim.cpp| & \verb|DEoptim()| \\
                      & \verb|devol()|    & & \verb|devol.cpp|    & \verb|devol()| \\
                      & \verb|permute()|  & & \verb|permute.cpp| & \verb|permute()| \\[6pt]
      \verb|evaluate.c|&  \verb|evaluate()| & & & \\[6pt]
        &             & & \verb|evaluate.h|& \phantom{XX} \verb|EvalBase class|  \\[6pt]
      \verb|get_element.c|\phantom{XX} &  \verb|getListElement()| & \phantom{XXXX} & & \\
      \bottomrule
    \end{tabular}
    \caption{Source file organisation for \proglang{C} files in \pkg{DEoptim}}
    \label{tab:Cfiles}
  \end{center}
\end{table}

The large file \verb|de4_0.c| has been split into three files: one each for
the core functions \verb|DEoptim()| (which is called from \proglang{R}),
\verb|devol()| (which is the core differential evolution optimisation
routine) and \verb|permute()| (which is a helper function used to shuffle
indices).  The evalution function has been replaced by a base class and two
virtual classes. These use of an objective function written in \proglang{R}
(as in \pkg{DEoptim}) as well as in \proglang{C++} which can lead to
substantial speed improvements. 
Section~\ref{sec:Cppchanges} discusses these changes in more detail.

\section[R changes]{\proglang{R} changes}
\label{sec:Rchanges}

TBD

\section[C++ changes]{\proglang{C++} changes}
\label{sec:Cppchanges}

\subsection[de4_0.c and deoptim.cpp]{\code{de4\_0.c} and \code{deoptim.cpp}}

\subsection[de4_0.c and devol.cpp]{\code{de4\_0.c} and \code{devol.cpp}}

\subsection[Evaluation functions in R and C++]{Evaluation functions in \proglang{R} and \proglang{C++}}

\section{Auxiliary files}

\section{Performance}

\section{Summary}

\bibliography{RcppDE}


\section*{Appendix}

%% R functions

\begin{sidewaysfigure}          % fig R1: beginning of DEoptim()
  \begin{minipage}{0.48\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
DEoptim <- function(fn, lower, upper, control = DEoptim.control(), ...) {
  fn1  <- function(par) fn(par, ...)
  if (length(lower) != length(upper))
    stop("'lower' and 'upper' are not of same length")
  if (!is.vector(lower))
    lower <- as.vector(lower)
  if (!is.vector(upper))
    upper <- as.vector(upper)
  if (any(lower > upper))
    stop("'lower' > 'upper'")
  if (any(lower == "Inf"))
    warning("you set a component of 'lower' to 'Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (any(lower == "-Inf"))
    warning("you set a component of 'lower' to '-Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (any(upper == "Inf"))
    warning("you set a component of 'upper' to 'Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (any(upper == "-Inf"))
    warning("you set a component of 'upper' to '-Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (!is.null(names(lower)))
    nam <- names(lower)
  else if (!is.null(names(upper)) & is.null(names(lower)))
    nam <- names(upper)
  else
    nam <- paste("par", 1:length(lower), sep = "")

  ctrl <- do.call(DEoptim.control, as.list(control))
  ctrl$npar <- length(lower)
  if (ctrl$NP < 4) {
    warning("'NP' < 4; set to default value 50\n", immediate. = TRUE)
    ctrl$NP <- 50
  }
  if (ctrl$NP < 10*length(lower)) 
    warning("For many problems it is best to set 'NP' (in 'control') to be at least "
            "ten times the length of the parameter vector. \n", immediate. = TRUE)
  if (!is.null(ctrl$initialpop)) {
    ctrl$specinitialpop <- TRUE
    if(!identical(as.numeric(dim(ctrl$initialpop)), c(ctrl$NP, ctrl$npar)))
      stop("Initial population is not a matrix with dim. NP x length(upper).")
  }
  else {
    ctrl$specinitialpop <- FALSE
    ctrl$initialpop <- 0.0
  }
  ##
  ctrl$trace <- as.numeric(ctrl$trace)
  ctrl$specinitialpop <- as.numeric(ctrl$specinitialpop)
  ctrl$initialpop <- as.numeric(ctrl$initialpop)
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{R} version in \pkg{DEoptim}}
    \tiny 

  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.48\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
DEoptim <- function(fn, lower, upper, control = DEoptim.control(), env, ...) {
  ##fn1  <- function(par) fn(par, ...)
  if (length(lower) != length(upper))
    stop("'lower' and 'upper' are not of same length")
  if (!is.vector(lower))
    lower <- as.vector(lower)
  if (!is.vector(upper))
    upper <- as.vector(upper)
  if (any(lower > upper))
    stop("'lower' > 'upper'")
  if (any(lower == "Inf"))
    warning("you set a component of 'lower' to 'Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (any(lower == "-Inf"))
    warning("you set a component of 'lower' to '-Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (any(upper == "Inf"))
    warning("you set a component of 'upper' to 'Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (any(upper == "-Inf"))
    warning("you set a component of 'upper' to '-Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (!is.null(names(lower)))
    nam <- names(lower)
  else if (!is.null(names(upper)) & is.null(names(lower)))
    nam <- names(upper)
  else
    nam <- paste("par", 1:length(lower), sep = "")
  if (missing(env))
    env <- new.env()

  ctrl <- do.call(DEoptim.control, as.list(control))
  ctrl$npar <- length(lower)
  if (ctrl$NP < 4) {
    warning("'NP' < 4; set to default value 50\n", immediate. = TRUE)
    ctrl$NP <- 50
  }
  if (ctrl$NP < 10*length(lower))
    warning("For many problems it is best to set 'NP' (in 'control') to be at least ten"
            " times the length of the parameter vector. \n", immediate. = TRUE)
  if (!is.null(ctrl$initialpop)) {
    ctrl$specinitialpop <- TRUE
    if(!identical(as.numeric(dim(ctrl$initialpop)), c(ctrl$NP, ctrl$npar)))
      stop("Initial population is not a matrix with dim. NP x length(upper).")
  }
  else {
    ctrl$specinitialpop <- FALSE
    ctrl$initialpop <- matrix(0,1,1)    # dummy matrix
  }
  ##
  ctrl$trace <- as.numeric(ctrl$trace)
  ctrl$specinitialpop <- as.numeric(ctrl$specinitialpop)
      \end{CodeInput}
    \end{CodeChunk}
 
    \normalsize
    \centering{Panel B: \proglang{R} version in \pkg{RcppDE}}
   \end{minipage}
  \caption{First half of \proglang{R} function \texttt{DEoptim()}}
  \label{fig:fig_R_DEoptim1}
\end{sidewaysfigure}

\begin{sidewaysfigure}          % fig R2: second half of DEoptim()
  \begin{minipage}{0.48\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
  outC <- .Call("DEoptimC", lower, upper, fn1, ctrl, new.env(),
               PACKAGE = "DEoptim")
  ##
  if (length(outC$storepop) > 0) {
    nstorepop <- floor((outC$iter - ctrl$storepopfrom) / ctrl$storepopfreq)
    storepop <- list()
    cnt <- 1
    for(i in 1:nstorepop) {
      idx <- cnt:((cnt - 1) + (ctrl$NP * ctrl$npar))
      storepop[[i]] <- matrix(outC$storepop[idx], nrow = ctrl$NP, ncol = ctrl$npar,
                         byrow = TRUE)
      cnt <- cnt + (ctrl$NP * ctrl$npar)
      dimnames(storepop[[i]]) <- list(1:ctrl$NP, nam)
    }
  }
  else {
    storepop = NULL
  }

  ## optim
  bestmem <- as.numeric(outC$bestmem)
  names(bestmem) <- nam
  bestval <- as.numeric(outC$bestval)
  nfeval <- as.numeric(outC$nfeval)
  iter <- as.numeric(outC$iter)

  ## member
  names(lower) <- names(upper) <- nam
  bestmemit <- matrix(outC$bestmemit, nrow = iter, 
                      ncol = ctrl$npar, byrow = TRUE)

  dimnames(bestmemit) <- list(1:iter, nam)
  bestvalit <- as.numeric(outC$bestvalit[1:iter])
  pop <- matrix(outC$pop, nrow = ctrl$NP, ncol = ctrl$npar,
                byrow = TRUE)
  storepop <- as.list(storepop)

  outR <- list(optim = list(
              bestmem = bestmem,
              bestval = bestval,
              nfeval = nfeval,
              iter = iter),
            member = list(
              lower = lower,
              upper = upper,
              bestmemit = bestmemit,
              bestvalit = bestvalit,
              pop = pop,
              storepop = storepop))

  attr(outR, "class") <- "DEoptim"
  return(outR)
}
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{R} version in \pkg{DEoptim}}
    \tiny 

  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.48\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
  outC <- .Call("DEoptim", lower, upper, fn, ctrl, env, PACKAGE = "RcppDE")
  ##
  if (length(outC$storepop) > 0) {
    nstorepop <- floor((outC$iter - ctrl$storepopfrom) / ctrl$storepopfreq)
    ## storepop <- list()
    ## cnt <- 1
    ## for(i in 1:nstorepop) {
    ##   idx <- cnt:((cnt - 1) + (ctrl$NP * ctrl$npar))
    ##   storepop[[i]] <- matrix(outC$storepop[idx], nrow = ctrl$NP, ncol = ctrl$npar,
    ##                      byrow = TRUE)
    ##   cnt <- cnt + (ctrl$NP * ctrl$npar)
    ##   dimnames(storepop[[i]]) <- list(1:ctrl$NP, nam)
    ## }
    storepop <- outC$storepop[1:nstorepop]
    for (i in 1:length(storepop)) dimnames(storepop[[i]]) <- list(1:ctrl$NP, nam)
  }
  else {
    storepop = NULL
  }

  ## optim
  bestmem <- as.numeric(outC$bestmem)
  names(bestmem) <- nam
  bestval <- as.numeric(outC$bestval)
  nfeval <- as.numeric(outC$nfeval)
  iter <- as.numeric(outC$iter)

  ## member
  names(lower) <- names(upper) <- nam
  #bestmemit <- matrix(outC$bestmemit, nrow = iter, ncol = ctrl$npar, byrow = TRUE)
  bestmemit <- outC$bestmemit

  dimnames(bestmemit) <- list(1:iter, nam)
  bestvalit <- as.numeric(outC$bestvalit[1:iter])
  #pop <- matrix(outC$pop, nrow = ctrl$NP, ncol = ctrl$npar, byrow = TRUE)
  pop <- outC$pop
  storepop <- as.list(storepop)

  outR <- list(optim = list(
              bestmem = bestmem,
              bestval = bestval,
              nfeval = nfeval,
              iter = iter),
            member = list(
              lower = lower,
              upper = upper,
              bestmemit = bestmemit,
              bestvalit = bestvalit,
              pop = pop,
              storepop = storepop))

  attr(outR, "class") <- "DEoptim"
  return(outR)
}
      \end{CodeInput}
    \end{CodeChunk}
 
    \normalsize
    \centering{Panel B: \proglang{R} version in \pkg{RcppDE}}
   \end{minipage}
  \caption{Second half of \proglang{R} function \texttt{DEoptim()}}
  \label{fig:fig_R_DEoptim2}
\end{sidewaysfigure}


%% C++ functions

\begin{sidewaysfigure}          % fig 1: beginning of DEoptimC / DEoptim
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
SEXP DEoptimC(SEXP lower, SEXP upper, SEXP fn, SEXP control, SEXP rho)
{
  int i, j;

  /* External pointers to return to R */
  SEXP sexp_bestmem, sexp_bestval, sexp_nfeval, sexp_iter,
    out, out_names, sexp_pop, sexp_storepop, sexp_bestmemit, sexp_bestvalit;

  if (!isFunction(fn))
    error("fn is not a function!");
  if (!isEnvironment(rho))
    error("rho is not an environment!");

  /*-----Initialization of annealing parameters-------------------------*/
  /* value to reach */
  double VTR = NUMERIC_VALUE(getListElement(control, "VTR"));
  /* chooses DE-strategy */
  int i_strategy = INTEGER_VALUE(getListElement(control, "strategy"));
  /* Maximum number of generations */
  int i_itermax = INTEGER_VALUE(getListElement(control, "itermax"));
  /* Number of objective function evaluations */
  long l_nfeval = (long)NUMERIC_VALUE(getListElement(control, "nfeval"));
  /* Dimension of parameter vector */
  int i_D = INTEGER_VALUE(getListElement(control, "npar"));
  /* Number of population members */
  int i_NP = INTEGER_VALUE(getListElement(control, "NP"));
  /* When to start storing populations */
  int i_storepopfrom = INTEGER_VALUE(getListElement(control, "storepopfrom"))-1;
  /* How often to store populations */
  int i_storepopfreq = INTEGER_VALUE(getListElement(control, "storepopfreq"));
  /* User-defined inital population */
  int i_specinitialpop = INTEGER_VALUE(getListElement(control, "specinitialpop"));
  double *initialpopv = NUMERIC_POINTER(getListElement(control, "initialpop"));
  /* User-defined bounds */
  double *f_lower = NUMERIC_POINTER(lower);
  double *f_upper = NUMERIC_POINTER(upper);
  /* stepsize */
  double f_weight = NUMERIC_VALUE(getListElement(control, "F"));
  /* crossover probability */
  double f_cross = NUMERIC_VALUE(getListElement(control, "CR"));
  /* Best of parent and child */
  int i_bs_flag = NUMERIC_VALUE(getListElement(control, "bs"));
  /* Print progress? */
  int i_trace = NUMERIC_VALUE(getListElement(control, "trace"));
  /* Re-evaluate best parameter vector? */
  int i_check_winner = NUMERIC_VALUE(getListElement(control, "checkWinner"));
  /* Average */
  int i_av_winner = NUMERIC_VALUE(getListElement(control, "avWinner"));
  /* p to define the top 100p% best solutions */
  double i_pPct = NUMERIC_VALUE(getListElement(control, "p"));
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{C} version}
    \tiny 

  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
RcppExport SEXP DEoptim(SEXP lowerS, SEXP upperS, SEXP fnS, SEXP controlS, SEXP rhoS) {
    
    try {
        Rcpp::NumericVector  f_lower(lowerS), f_upper(upperS);          // User-defined bounds
        Rcpp::List           control(controlS);                         // named list of params

        double VTR           = Rcpp::as<double>(control["VTR"]);        // value to reach
        int i_strategy       = Rcpp::as<int>(control["strategy"]);      // chooses DE-strategy
        int i_itermax        = Rcpp::as<int>(control["itermax"]);       // Maximum number of generations
        long l_nfeval        = 0;                                       // nb of function evals (NOT passed in)
        int i_D              = Rcpp::as<int>(control["npar"]);          // Dimension of parameter vector
        int i_NP             = Rcpp::as<int>(control["NP"]);            // Number of population members
        int i_storepopfrom   = Rcpp::as<int>(control["storepopfrom"]) - 1;  // When to start storing populations 
        int i_storepopfreq   = Rcpp::as<int>(control["storepopfreq"]);  // How often to store populations 
        int i_specinitialpop = Rcpp::as<int>(control["specinitialpop"]);// User-defined inital population 
        Rcpp::NumericMatrix initialpopm = Rcpp::as<Rcpp::NumericMatrix>(control["initialpop"]);
        double f_weight      = Rcpp::as<double>(control["F"]);          // stepsize 
        double f_cross       = Rcpp::as<double>(control["CR"]);         // crossover probability 
        int i_bs_flag        = Rcpp::as<int>(control["bs"]);            // Best of parent and child 
        int i_trace          = Rcpp::as<int>(control["trace"]);         // Print progress? 
        int i_check_winner   = Rcpp::as<int>(control["checkWinner"]);   // Re-evaluate best parameter vector? 
        int i_av_winner      = Rcpp::as<int>(control["avWinner"]);      // Average 
        double i_pPct        = Rcpp::as<double>(control["p"]);          // p to define the top 100p% best solutions 

      \end{CodeInput}
    \end{CodeChunk}
 
    \normalsize
    \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
   \end{minipage}
  \caption{Beginning of \code{DEoptim()} \proglang{C/C++} function}
  \label{fig:deoptim_start1}
\end{sidewaysfigure}

\begin{sidewaysfigure}          % fig 2: memory allocations
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
  /* Data structures for parameter vectors */
  double **gta_popP = (double **)R_alloc(i_NP*2,sizeof(double *));
  for (int i = 0; i < (i_NP*2); i++) 
    gta_popP[i] = (double *)R_alloc(i_D,sizeof(double));

  double **gta_oldP = (double **)R_alloc(i_NP,sizeof(double *));
  for (int i = 0; i < i_NP; i++) 
    gta_oldP[i] = (double *)R_alloc(i_D,sizeof(double));

  double **gta_newP = (double **)R_alloc(i_NP,sizeof(double *));
  for (int i = 0; i < i_NP; i++) 
    gta_newP[i] = (double *)R_alloc(i_D,sizeof(double));
  
  double *gt_bestP = (double *)R_alloc(1,sizeof(double) * i_D);

  /* Data structures for objective function values associated with
   * parameter vectors */
  double *gta_popC = (double *)R_alloc(i_NP*2,sizeof(double));
  double *gta_oldC = (double *)R_alloc(i_NP,sizeof(double));
  double *gta_newC = (double *)R_alloc(i_NP,sizeof(double));
  double *gt_bestC = (double *)R_alloc(1,sizeof(double));

  double *t_bestitP = (double *)R_alloc(1,sizeof(double) * i_D);
  double *t_tmpP = (double *)R_alloc(1,sizeof(double) * i_D);
  double *tempP = (double *)R_alloc(1,sizeof(double) * i_D);

  int i_nstorepop = ceil((i_itermax - i_storepopfrom) / i_storepopfreq);
  double *gd_pop = (double *)R_alloc(i_NP*i_D,sizeof(double));
  double *gd_storepop = (double *)R_alloc(i_NP,sizeof(double) * i_D * i_nstorepop);
  double *gd_bestmemit = (double *)R_alloc(i_itermax*i_D,sizeof(double));
  double *gd_bestvalit = (double *)R_alloc(i_itermax,sizeof(double));
  int gi_iter = 0;
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{C} version}
    \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
        arma::colvec minbound(f_lower.begin(), f_lower.size(), false);  // convert Rcpp vectors to arma vectors
        arma::colvec maxbound(f_upper.begin(), f_upper.size(), false);
        arma::mat initpopm(initialpopm.begin(), initialpopm.rows(), initialpopm.cols(), false);

        arma::mat ta_popP(i_D, i_NP*2);                                 // Data structures for parameter vectors 
        arma::mat ta_oldP(i_D, i_NP);
        arma::mat ta_newP(i_D, i_NP);
        arma::colvec t_bestP(i_D); 

        arma::colvec ta_popC(i_NP*2);                                   // Data structures for obj. fun. values 
        arma::colvec ta_oldC(i_NP);
        arma::colvec ta_newC(i_NP);
        double t_bestC; 

        arma::colvec t_bestitP(i_D);
        arma::colvec t_tmpP(i_D); 

        int i_nstorepop = ceil((i_itermax - i_storepopfrom) / i_storepopfreq);
        arma::mat d_pop(i_D, i_NP); 
        Rcpp::List d_storepop(i_nstorepop);
        arma::mat d_bestmemit(i_D, i_itermax);       
        arma::colvec d_bestvalit(i_itermax);     
        int i_iter = 0;
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize
    \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{Memory allocation in \code{DEoptim()} \proglang{C/C++} function}
  \label{fig:deoptim_memory}
\end{sidewaysfigure}


\begin{sidewaysfigure}          % fig 3: devol and arguments
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
  /*---optimization--------------------------------------*/
  devol(VTR, f_weight, f_cross, i_bs_flag, f_lower, f_upper, fn, rho, i_trace,
        i_strategy, i_D, i_NP, i_itermax,
        initialpopv, i_storepopfrom, i_storepopfreq, 
        i_specinitialpop, i_check_winner, i_av_winner,
        gta_popP, gta_oldP, gta_newP, gt_bestP,
        gta_popC, gta_oldC, gta_newC, gt_bestC,
        t_bestitP, t_tmpP, tempP,
        gd_pop, gd_storepop, gd_bestmemit, gd_bestvalit,
        &gi_iter, i_pPct, &l_nfeval);
  /*---end optimization----------------------------------*/

  PROTECT(sexp_bestmem = NEW_NUMERIC(i_D));
  for (i = 0; i < i_D; i++) {
    NUMERIC_POINTER(sexp_bestmem)[i] = gt_bestP[i];
  }

  j = i_NP * i_D;
  PROTECT(sexp_pop = NEW_NUMERIC(j));
  for (i = 0; i < j; i++)
    NUMERIC_POINTER(sexp_pop)[i] = gd_pop[i];

  j =  i_nstorepop * i_NP * i_D;
  PROTECT(sexp_storepop = NEW_NUMERIC(j));
  for (i = 0; i < j; i++)
    NUMERIC_POINTER(sexp_storepop)[i] = gd_storepop[i];

  j = gi_iter * i_D;
  PROTECT(sexp_bestmemit = NEW_NUMERIC(j));
  for (i = 0; i < j; i++) 
    NUMERIC_POINTER(sexp_bestmemit)[i] = gd_bestmemit[i];
  j = gi_iter;
  PROTECT(sexp_bestvalit = NEW_NUMERIC(j));
  for (i = 0; i < j; i++)
    NUMERIC_POINTER(sexp_bestvalit)[i] = gd_bestvalit[i];

  PROTECT(sexp_bestval = NEW_NUMERIC(1));
  NUMERIC_POINTER(sexp_bestval)[0] = gt_bestC[0];

  PROTECT(sexp_nfeval = NEW_INTEGER(1));
  //INTEGER_POINTER(sexp_nfeval)[0] = 0;
  INTEGER_POINTER(sexp_nfeval)[0] = l_nfeval;

  PROTECT(sexp_iter = NEW_INTEGER(1));
  INTEGER_POINTER(sexp_iter)[0] = gi_iter;

  PROTECT(out = NEW_LIST(8));
  SET_VECTOR_ELT(out, 0, sexp_bestmem);
  SET_VECTOR_ELT(out, 1, sexp_bestval);
  SET_VECTOR_ELT(out, 2, sexp_nfeval);
  SET_VECTOR_ELT(out, 3, sexp_iter);
  SET_VECTOR_ELT(out, 4, sexp_bestmemit);
  SET_VECTOR_ELT(out, 5, sexp_bestvalit);
  SET_VECTOR_ELT(out, 6, sexp_pop);
  SET_VECTOR_ELT(out, 7, sexp_storepop);
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{C} version}
    \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
  PROTECT(out_names = NEW_STRING(8));
  SET_STRING_ELT(out_names, 0, mkChar("bestmem"));
  SET_STRING_ELT(out_names, 1, mkChar("bestval"));
  SET_STRING_ELT(out_names, 2, mkChar("nfeval"));
  SET_STRING_ELT(out_names, 3, mkChar("iter"));
  SET_STRING_ELT(out_names, 4, mkChar("bestmemit"));
  SET_STRING_ELT(out_names, 5, mkChar("bestvalit"));
  SET_STRING_ELT(out_names, 6, mkChar("pop"));
  SET_STRING_ELT(out_names, 7, mkChar("storepop"));

  SET_NAMES(out, out_names);

  UNPROTECT(10);

  return out;
}
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{C} version (in both columns)}
    \tiny 

    \bigskip
    \phantom{XX}
    \bigskip
    \phantom{XX}
    \bigskip
    \phantom{XX}
    \bigskip


    \begin{CodeChunk}
      \begin{CodeInput}
	// call actual Differential Evolution optimization given the parameters
	devol(VTR, f_weight, f_cross, i_bs_flag, minbound, maxbound, fnS, rhoS, i_trace, i_strategy, i_D, i_NP, 
	      i_itermax, initpopm, i_storepopfrom, i_storepopfreq, i_specinitialpop, i_check_winner, i_av_winner,
	      ta_popP, ta_oldP, ta_newP, t_bestP, ta_popC, ta_oldC, ta_newC, t_bestC, t_bestitP, t_tmpP,
	      d_pop, d_storepop, d_bestmemit, d_bestvalit, i_iter, i_pPct, l_nfeval);

	return Rcpp::List::create(Rcpp::Named("bestmem")   = t_bestP,	// and return a named list with results to R
				  Rcpp::Named("bestval")   = t_bestC,
				  Rcpp::Named("nfeval")    = l_nfeval,
				  Rcpp::Named("iter")      = i_iter,
				  Rcpp::Named("bestmemit") = trans(d_bestmemit),
				  Rcpp::Named("bestvalit") = d_bestvalit,
				  Rcpp::Named("pop")       = trans(d_pop),
				  Rcpp::Named("storepop")  = d_storepop); 

    } catch( std::exception& ex) { 
	forward_exception_to_r(ex); 
    } catch(...) { 
	::Rf_error( "c++ exception (unknown reason)"); 
    }
    return R_NilValue;
}
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize 
    \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{DEoptim()} call of \code{devol()} and return of results to \proglang{R}}
  \label{fig:deoptim_end}
\end{sidewaysfigure}



\begin{sidewaysfigure}          % fig 4: devol and arguments
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
void devol(double VTR, double f_weight, double f_cross, int i_bs_flag,
    double *lower, double *upper, SEXP fcall, SEXP rho, int trace, 
    int i_strategy, int i_D, int i_NP, int i_itermax,
    double *initialpopv, int i_storepopfrom, int i_storepopfreq, 
    int i_specinitialpop, int i_check_winner, int i_av_winner,
    double **gta_popP, double **gta_oldP, double **gta_newP, double *gt_bestP,
    double *gta_popC, double *gta_oldC, double *gta_newC, double *gt_bestC,
    double *t_bestitP, double *t_tmpP, double *tempP,
    double *gd_pop, double *gd_storepop, double *gd_bestmemit, double *gd_bestvalit,
    int *gi_iter, double i_pPct, long *l_nfeval)
{

#define URN_DEPTH  5   /* 4 + one index to avoid */

  /* initialize parameter vector to pass to evaluate function */
  SEXP par; PROTECT(par = NEW_NUMERIC(i_D));
  
  int i, j, k, x;  /* counting variables */
  int i_r1, i_r2, i_r3, i_r4;  /* placeholders for random indexes */

  int ia_urn2[URN_DEPTH];
  int i_nstorepop, i_xav;
  i_nstorepop = ceil((i_itermax - i_storepopfrom) / i_storepopfreq);
  
  int popcnt, bestacnt, same; /* lazy cnters */

  double *fa_minbound = lower;
  double *fa_maxbound = upper;
  double f_jitter, f_dither;
 
  double t_bestitC;
  double t_tmpC, tmp_best; 
  
  double initialpop[i_NP][i_D];
  
  /* vars for DE/current-to-p-best/1 */
  int i_pbest;
  int p_NP = round(i_pPct * i_NP);  /* choose at least two best solutions */
      p_NP = p_NP < 2 ? 2 : p_NP;
  int sortIndex[i_NP];              /* sorted values of gta_oldC */
  for(i = 0; i < i_NP; i++) sortIndex[i] = i;

  /* vars for when i_bs_flag == 1 */
  int i_len, done, step, bound;
  double tempC;

  GetRNGstate();

  gta_popP[0][0] = 0;
      \end{CodeInput}
    \end{CodeChunk}
    \normalsize 
    \centering{Panel A: \proglang{C} version}
    \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
void devol(double VTR, double f_weight, double f_cross, int i_bs_flag,
           arma::colvec & fa_minbound, arma::colvec & fa_maxbound, SEXP fcall, SEXP rho, int i_trace,
           int i_strategy, int i_D, int i_NP, int i_itermax, arma::mat & initialpopm, 
	   int i_storepopfrom, int i_storepopfreq, int i_specinitialpop, int i_check_winner, int i_av_winner,
           arma::mat &ta_popP, arma::mat &ta_oldP, arma::mat &ta_newP, arma::colvec & t_bestP, 
           arma::colvec & ta_popC, arma::colvec & ta_oldC, arma::colvec & ta_newC, double & t_bestC,
           arma::colvec & t_bestitP, arma::colvec & t_tmpP, 
           arma::mat &d_pop, Rcpp::List &d_storepop, arma::mat & d_bestmemit, arma::colvec & d_bestvalit,
           int & i_iterations, double i_pPct, long & l_nfeval) {

    Rcpp::DE::EvalBase *ev = NULL; 		// pointer to abstract base class
    if (TYPEOF(fcall) == EXTPTRSXP) { 		// non-standard mode: we are being passed an external pointer
	ev = new Rcpp::DE::EvalCompiled(fcall); // so assign a pointer using external pointer in fcall SEXP
    } else {					// standard mode: env_ is an env, fcall_ is a function 
	ev = new Rcpp::DE::EvalStandard(fcall, rho);	// so assign R function and environment
    }
    const int urn_depth = 5;   			// 4 + one index to avoid 
    Rcpp::NumericVector par(i_D);		// initialize parameter vector to pass to evaluate function 
    arma::icolvec::fixed<urn_depth> ia_urn2; 	// fixed-size vector for urn draws
    arma::icolvec ia_urntmp(i_NP); 		// so that we don't need to re-allocated each time in permute
    arma::mat initialpop(i_D, i_NP); 
    int i_nstorepop = ceil((i_itermax - i_storepopfrom) / i_storepopfreq);
    int p_NP = round(i_pPct * i_NP);  		// choose at least two best solutions 
    p_NP = p_NP < 2 ? 2 : p_NP;
    arma::icolvec sortIndex(i_NP); 		// sorted values of ta_oldC 
    if (i_strategy == 6) {
	for (int i = 0; i < i_NP; i++) 
	    sortIndex[i] = i; 
    }
    GetRNGstate();
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} beginning}
  \label{fig:deoptim_end}
\end{sidewaysfigure}



\begin{sidewaysfigure}          % fig 5: devol inits
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
  /* initialize initial popuplation */
  for (int i = 0; i < i_NP; i++) {
    for (int j = 0; j < i_D; j++) {
      initialpop[i][j] = 0.0;
    }
  }

  /* initialize best members */
  for (int i = 0; i < i_itermax * i_D; i++)
    gd_bestmemit[i] = 0.0;

  /* initialize best values */
  for (int i = 0; i < i_itermax; i++)
    gd_bestvalit[i] = 0.0;

  /* initialize best population */
  for (int i = 0; i < i_NP * i_D; i++)
    gd_pop[i] = 0.0;

  /* initialize stored populations */
  if (i_nstorepop < 0)
    i_nstorepop = 0;

  for (int i = 0; i < (i_nstorepop * i_NP * i_D); i++)
    gd_storepop[i] = 0.0;
      
  /* if initial population provided, initialize with values */
  if (i_specinitialpop > 0) {
    k = 0;
    
    for (j = 0; j < i_D; j++) {
      for (i = 0; i < i_NP; i++) {
        initialpop[i][j] = initialpopv[k];
        k += 1;
      }
    }
  }

  /* number of function evaluations
   * (this is an input via DEoptim.control, but we over-write it?) */
  *l_nfeval = 0;

  /*------Initialization-----------------------------*/
  for (i = 0; i < i_NP; i++) {
    for (j = 0; j < i_D; j++) {
      if (i_specinitialpop <= 0) { /* random initial member */
        gta_popP[i][j] = fa_minbound[j] +
        unif_rand() * (fa_maxbound[j] - fa_minbound[j]);

      }
      else /* or user-specified initial member */
        gta_popP[i][j] = initialpop[i][j];
    } 
    gta_popC[i] = evaluate(l_nfeval, gta_popP[i], par, fcall, rho);

    if (i == 0 || gta_popC[i] <= gt_bestC[0]) {
      gt_bestC[0] = gta_popC[i];
      for (j = 0; j < i_D; j++)  
        gt_bestP[j]=gta_popP[i][j];
    }
  }
      \end{CodeInput}
    \end{CodeChunk}

    %\normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}

  /*---assign pointers to current ("old") population---*/
  gta_oldP = gta_popP;
  gta_oldC = gta_popC;
  
  /*------Iteration loop--------------------------------------------*/
  int i_iter = 0;
  popcnt = 0;
  bestacnt = 0;
  i_xav = 1;
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{C} version (in both columns)}
    \tiny 

    \bigskip
    \phantom{XX}
    \bigskip
    \phantom{XX}
    \bigskip
    \phantom{XX}
    \bigskip


    \begin{CodeChunk}
      \begin{CodeInput}
    initialpop.zeros();                         // initialize initial popuplation 
    d_bestmemit.zeros();                        // initialize best members
    d_bestvalit.zeros();                        // initialize best values 
    d_pop.zeros();                              // initialize best population
    i_nstorepop = (i_nstorepop < 0) ? 0 : i_nstorepop;
      
    if (i_specinitialpop > 0) {                 // if initial population provided, initialize with values 
        initialpop = trans(initialpopm);        // transpose as we prefer columns for population members here
    }

    for (int i = 0; i < i_NP; i++) {            // ------Initialization-----------------------------
        if (i_specinitialpop <= 0) {            // random initial member 
            for (int j = 0; j < i_D; j++) {
                ta_popP.at(j,i) = fa_minbound[j] + ::unif_rand() * (fa_maxbound[j] - fa_minbound[j]);
            }
        } else {                                // or user-specified initial member 
            ta_popP.col(i) = initialpop.col(i);
        } 
        memcpy(REAL(par), ta_popP.colptr(i), Rf_nrows(par) * sizeof(double));      
        ta_popC[i] = ev->eval(par);
        if (i == 0 || ta_popC[i] <= t_bestC) {
            t_bestC = ta_popC[i];
            t_bestP = ta_popP.unsafe_col(i);
        }
    }

    ta_oldP = ta_popP.cols(0, i_NP-1);          // ---assign pointers to current ("old") population---
    ta_oldC = ta_popC.rows(0, i_NP-1);
  
    int i_iter = 0;                             // ------Iteration loop--------------------------------------------
    int popcnt = 0;
    int i_xav = 1;
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize 
    \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} initializations}
  \label{fig:deoptim_end}
\end{sidewaysfigure}




\begin{sidewaysfigure}          % fig 6: devol and arguments
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
  /* loop */
  while ((i_iter < i_itermax) && (gt_bestC[0] > VTR))
    {
      /* store intermediate populations */
      if (i_iter % i_storepopfreq == 0 && i_iter >= i_storepopfrom) {
	for (i = 0; i < i_NP; i++) {
	  for (j = 0; j < i_D; j++) {
	    gd_storepop[popcnt] = gta_oldP[i][j];
	    popcnt++;
	  }
	}
      } /* end store pop */
      
      /* store the best member */
      for(j = 0; j < i_D; j++) {
	gd_bestmemit[bestacnt] = gt_bestP[j];
	bestacnt++;
      }
      /* store the best value */
      gd_bestvalit[i_iter] = gt_bestC[0];
      
      for (j = 0; j < i_D; j++) 
        t_bestitP[j] = gt_bestP[j];
      t_bestitC = gt_bestC[0];
      
      i_iter++;
     
      /*----computer dithering factor -----------------*/
      f_dither = f_weight + unif_rand() * (1.0 - f_weight);
      
      /*---DE/current-to-p-best/1 ---------------------------------*/
      if (i_strategy == 6) {
        /* create a copy of gta_oldC to avoid changing it */
        double temp_oldC[i_NP];
        for(j = 0; j < i_NP; j++) temp_oldC[j] = gta_oldC[j];
        
        /* sort temp_oldC to use sortIndex later */
        rsort_with_index( (double*)temp_oldC, (int*)sortIndex, i_NP );
      }

      /*----start of loop through ensemble-------------------------*/
      for (i = 0; i < i_NP; i++) {

	/*t_tmpP is the vector to mutate and eventually select*/
	for (j = 0; j < i_D; j++) 
	  t_tmpP[j] = gta_oldP[i][j];
	t_tmpC = gta_oldC[i];

	permute(ia_urn2, URN_DEPTH, i_NP, i); /* Pick 4 random and distinct */

	i_r1 = ia_urn2[1];  /* population members */
	i_r2 = ia_urn2[2];
	i_r3 = ia_urn2[3];
	i_r4 = ia_urn2[4];
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
    while ((i_iter < i_itermax) && (t_bestC > VTR)) {    // main loop ====================================
        if (i_iter % i_storepopfreq == 0 && i_iter >= i_storepopfrom) {         // store intermediate populations
            d_storepop[popcnt++] = Rcpp::wrap( trans(ta_oldP) );
        } // end store pop 

        d_bestmemit.col(i_iter) = t_bestP;      // store the best member
        d_bestvalit[i_iter] = t_bestC;          // store the best value 
        t_bestitP = t_bestP;
        i_iter++;                               // increase iteration counter
     
        double f_dither = f_weight + ::unif_rand() * (1.0 - f_weight);  // ----computer dithering factor --------------
      
        if (i_strategy == 6) {                  // ---DE/current-to-p-best/1 ------------------------------------------
            arma::colvec temp_oldC = ta_oldC;                           // create copy of ta_oldC to avoid changing it 
            rsort_with_index( temp_oldC.memptr(), sortIndex.begin(), i_NP );    // sort temp_oldC to use sortIndex 
        }

        for (int i = 0; i < i_NP; i++) {        // ----start of loop through ensemble------------------------

            t_tmpP = ta_oldP.col(i);            // t_tmpP is the vector to mutate and eventually select

            permute(ia_urn2.memptr(), urn_depth, i_NP, i, ia_urntmp.memptr()); // Pick 4 random and distinct 
            int k = 0;                          // loop counter used in all strategies below 
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} iteration loop setup and beginning of population loop}
  \label{fig:deoptim_end}
\end{sidewaysfigure}


\begin{sidewaysfigure}          % fig 7: devol main loop and top of strat loop
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
	/*===Choice of strategy=======================================================*/
	/*---classical strategy DE/rand/1/bin-----------------------------------------*/
	if (i_strategy == 1) {
	  
	  j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  do {
	    /* add fluctuation to random target */
	    t_tmpP[j] = gta_oldP[i_r1][j] +
	      f_weight * (gta_oldP[i_r2][j] - gta_oldP[i_r3][j]);

	    j = (j + 1) % i_D;
	    k++;
	  }while((unif_rand() < f_cross) && (k < i_D));

	}
	/*---DE/local-to-best/1/bin---------------------------------------------------*/
	else if (i_strategy == 2) {
	 
	  j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  do {
	    /* add fluctuation to random target */
	   
	    t_tmpP[j] = t_tmpP[j] + 
	      f_weight * (t_bestitP[j] - t_tmpP[j]) +
	      f_weight * (gta_oldP[i_r2][j] - gta_oldP[i_r3][j]);
	    j = (j + 1) % i_D;
	    k++;
	  }while((unif_rand() < f_cross) && (k < i_D));

	}
	/*---DE/best/1/bin with jitter------------------------------------------------*/
	else if (i_strategy == 3) {
	 	  
	  j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  do {
	    /* add fluctuation to random target */
	    f_jitter = 0.0001 * unif_rand() + f_weight;
	    t_tmpP[j] = t_bestitP[j] +
	      f_jitter * (gta_oldP[i_r1][j] - gta_oldP[i_r2][j]);
	    
	    j = (j + 1) % i_D;
	    k++;
	  }while((unif_rand() < f_cross) && (k < i_D));

	}
	/*---DE/rand/1/bin with per-vector-dither-------------------------------------*/
	else if (i_strategy == 4) {
		  
	  j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  do {
	    /* add fluctuation to random target */
	    t_tmpP[j] = gta_oldP[i_r1][j] +
	      (f_weight + unif_rand()*(1.0 - f_weight))*
	      (gta_oldP[i_r2][j]-gta_oldP[i_r3][j]);

	    j = (j + 1) % i_D;
	    k++;
	  }while((unif_rand() < f_cross) && (k < i_D));

	}
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
	    // ===Choice of strategy=======================================================
	    switch (i_strategy) {

	    case 1: {				// ---classical strategy DE/rand/1/bin---------------------------------
		int j = static_cast<int>(::unif_rand() * i_D);	// random parameter 
		do {				// add fluctuation to random target 
		    t_tmpP[j] = ta_oldP.at(j,ia_urn2[1]) + f_weight * 
			(ta_oldP.at(j,ia_urn2[2]) - ta_oldP.at(j,ia_urn2[3]));
		    j = (j + 1) % i_D;
		} while ((::unif_rand() < f_cross) && (++k < i_D));
		break;
	    }
	    case 2: {				// ---DE/local-to-best/1/bin-------------------------------------------
		int j = static_cast<int>(::unif_rand() * i_D);	// random parameter 
		do {				// add fluctuation to random target 
		    t_tmpP[j] = t_tmpP[j] + f_weight * (t_bestitP[j] - t_tmpP[j]) + f_weight * 
			(ta_oldP.at(j,ia_urn2[2]) - ta_oldP.at(j,ia_urn2[3]));
		    j = (j + 1) % i_D;
		} while ((::unif_rand() < f_cross) && (++k < i_D));
		break;
	    }
	    case 3: {				// ---DE/best/1/bin with jitter---------------------------------------
		int j = static_cast<int>(::unif_rand() * i_D);	// random parameter 
		do {				// add fluctuation to random target 
		    double f_jitter = 0.0001 * ::unif_rand() + f_weight; 
		    t_tmpP[j] = t_bestitP[j] + f_jitter * (ta_oldP.at(j,ia_urn2[1]) - ta_oldP.at(j,ia_urn2[2]));
		    j = (j + 1) % i_D;
		} while ((::unif_rand() < f_cross) && (++k < i_D));
		break;
	    }
	    case 4: {				// ---DE/rand/1/bin with per-vector-dither----------------------------
		int j = static_cast<int>(::unif_rand() * i_D);	// random parameter 
		do {				// add fluctuation to random target *
		    t_tmpP[j] = ta_oldP.at(j,ia_urn2[1]) + (f_weight + ::unif_rand()*(1.0 - f_weight)) 
			* (ta_oldP.at(j,ia_urn2[2]) - ta_oldP.at(j,ia_urn2[3]));
		    j = (j + 1) % i_D;
		} while ((::unif_rand() < f_cross) && (++k < i_D));
		break;
	    }
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} first four strategy options}
  \label{fig:deoptim_end}
\end{sidewaysfigure}



\begin{sidewaysfigure}          % fig 8: bottom of strat loop
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
	/*---DE/rand/1/bin with per-generation-dither---------------------------------*/
	else if (i_strategy == 5) {
	  
	  j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  do {
	    /* add fluctuation to random target */
	    t_tmpP[j] = gta_oldP[i_r1][j] +
	      f_dither * (gta_oldP[i_r2][j] - gta_oldP[i_r3][j]);
	    
	    j = (j + 1) % i_D;
	    k++;
	  }while((unif_rand() < f_cross) && (k < i_D));
       
	}
	/*---DE/current-to-p-best/1 (JADE)--------------------------------------------*/
	else if (i_strategy == 6) {

          /* select from [0, 1, 2, ..., (pNP-1)] */
          i_pbest = sortIndex[(int)(unif_rand() * p_NP)];
	  
          j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  do {
	    /* add fluctuation to random target */
	    t_tmpP[j] = gta_oldP[i][j] +
              f_weight * (gta_oldP[i_pbest][j] - gta_oldP[i][j]) +
              f_weight * (gta_oldP[i_r1][j]    - gta_oldP[i_r2][j]);
	    
	    j = (j + 1) % i_D;
	    k++;
	  }while((unif_rand() < f_cross) && (k < i_D));

        }
	/*---variation to DE/rand/1/bin: either-or-algorithm--------------------------*/
	else {
	  
	  j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  if (unif_rand() < 0.5) { /* differential mutation, Pmu = 0.5 */
	    do {
	      /* add fluctuation to random target */
	      t_tmpP[j] = gta_oldP[i_r1][j] +
		f_weight * (gta_oldP[i_r2][j] - gta_oldP[i_r3][j]);
	      
	      j = (j + 1) % i_D;
	      k++;
	    }while((unif_rand() < f_cross) && (k < i_D));
	  }
	  else {
	    /* recombination with K = 0.5*(F+1) -. F-K-Rule */
	    do {
	      /* add fluctuation to random target */
	      t_tmpP[j] = gta_oldP[i_r1][j] +
		0.5 * (f_weight + 1.0) * (gta_oldP[i_r2][j]
					  + gta_oldP[i_r3][j] - 2 * gta_oldP[i_r1][j]);
	      
	      j = (j + 1) % i_D;
	      k++;
	    }while((unif_rand() < f_cross) && (k < i_D));

	  }
	}/* end if (i_strategy ...*/
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
	    casee 5: {				// ---DE/rand/1/bin with per-generation-dither---------------
		int j = static_cast<int>(::unif_rand() * i_D); 	// random parameter 
		do {				// add fluctuation to random target 
		    t_tmpP[j] = ta_oldP.at(j,ia_urn2[1]) + f_dither 
			* (ta_oldP.at(j,ia_urn2[2]) - ta_oldP.at(j,ia_urn2[3]));
		    j = (j + 1) % i_D;
		} while ((::unif_rand() < f_cross) && (++k < i_D));
		break;
	    }
	    case 6: {				// ---DE/current-to-p-best/1 (JADE)--------------------------
                // select from [0, 1, 2, ..., (pNP-1)] 
		int i_pbest = sortIndex[static_cast<int>(::unif_rand() * p_NP)]; 
		int j = static_cast<int>(::unif_rand() * i_D); 	// random parameter 
		do {				// add fluctuation to random target 
		    t_tmpP[j] = ta_oldP.at(j,i) + f_weight * (ta_oldP.at(j,i_pbest) - ta_oldP.at(j,i)) + 
			f_weight * (ta_oldP.at(j,ia_urn2[1]) - ta_oldP.at(j,ia_urn2[2]));
		    j = (j + 1) % i_D;
		} while ((::unif_rand() < f_cross) && (++k < i_D));
		break;
	    }
	    default: {				// ---variation to DE/rand/1/bin: either-or-algorithm--------
		int j = static_cast<int>(::unif_rand() * i_D); 	// random parameter 
		if (::unif_rand() < 0.5) { 	// differential mutation, Pmu = 0.5 
		    do {			// add fluctuation to random target */
			t_tmpP[j] = ta_oldP.at(j,ia_urn2[1]) + f_weight *
                                        (ta_oldP.at(j,ia_urn2[2]) - ta_oldP.at(j,ia_urn2[3]));
			j = (j + 1) % i_D;
		    } while ((::unif_rand() < f_cross) && (++k < i_D));

		} else { 			// recombination with K = 0.5*(F+1) -. F-K-Rule 
		    do {			// add fluctuation to random target */
			t_tmpP[j] = ta_oldP.at(j,ia_urn2[1]) + 0.5 * (f_weight + 1.0) * 
			    (ta_oldP.at(j,ia_urn2[2]) + ta_oldP.at(j,ia_urn2[3]) - 2 * ta_oldP.at(j,ia_urn2[1]));
			j = (j + 1) % i_D;
		    } while ((::unif_rand() < f_cross) && (++k < i_D));
		}
		break;
	    }
	    } // end switch (i_strategy) ...
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} remaining three strategy options}
  \label{fig:deoptim_end}
\end{sidewaysfigure}




\begin{sidewaysfigure}          % fig 9: remainder of core loop
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
	/*----boundary constraints, bounce-back method was not enforcing bounds correctly*/
	for (j = 0; j < i_D; j++) {
	  if (t_tmpP[j] < fa_minbound[j]) {
	    t_tmpP[j] = fa_minbound[j] +
	      unif_rand() * (fa_maxbound[j] - fa_minbound[j]);
	  }
	  if (t_tmpP[j] > fa_maxbound[j]) {
	    t_tmpP[j] =  fa_maxbound[j] -
	      unif_rand() * (fa_maxbound[j] - fa_minbound[j]);
	  }
	}

	/*------Trial mutation now in t_tmpP-----------------*/
	/* Evaluate mutant in t_tmpP[]*/

	t_tmpC = evaluate(l_nfeval, t_tmpP, par, fcall, rho); 
	
	/* note that i_bs_flag means that we will choose the
	 *best NP vectors from the old and new population later*/
	if (t_tmpC <= gta_oldC[i] || i_bs_flag) {
	  /* replace target with mutant */
	  for (j = 0; j < i_D; j++) 
	    gta_newP[i][j]=t_tmpP[j];
	  gta_newC[i]=t_tmpC;
	  if (t_tmpC <= gt_bestC[0]) {
	    for (j = 0; j < i_D; j++) 
	      gt_bestP[j]=t_tmpP[j];
	    gt_bestC[0]=t_tmpC;
	  }
	} 
	else {
	  for (j = 0; j < i_D; j++) 
	    gta_newP[i][j]=gta_oldP[i][j];
	  gta_newC[i]=gta_oldC[i];
	  
	}
      } /* End mutation loop through pop. */
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
	    for (int j = 0; j < i_D; j++) {	// boundary constraints, bounce-back method was not enforcing bounds 
		if (t_tmpP[j] < fa_minbound[j]) {
		    t_tmpP[j] = fa_minbound[j] + ::unif_rand() * (fa_maxbound[j] - fa_minbound[j]);
		}
		if (t_tmpP[j] > fa_maxbound[j]) {
		    t_tmpP[j] = fa_maxbound[j] - ::unif_rand() * (fa_maxbound[j] - fa_minbound[j]);
		}
	    }

	    // ------Trial mutation now in t_tmpP-----------------
	    memcpy(REAL(par), t_tmpP.memptr(), Rf_nrows(par) * sizeof(double));      
	    double t_tmpC = ev->eval(par);				// Evaluate mutant in t_tmpP
	    if (t_tmpC <= ta_oldC[i] || i_bs_flag) {	    		// i_bs_flag means will choose best NP later
		ta_newP.col(i) = t_tmpP;				// replace target with mutant 
		ta_newC[i] = t_tmpC;
		if (t_tmpC <= t_bestC) {
		    t_bestP = t_tmpP;
		    t_bestC = t_tmpC;
		}
	    } else {
		ta_newP.col(i) = ta_oldP.col(i);
		ta_newC[i] = ta_oldC[i];
	    }
	} // End mutation loop through pop., ie the "for (i = 0; i < i_NP; i++)"
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} remainder of population mutation loop}
  \label{fig:deoptim_end}
\end{sidewaysfigure}


\begin{sidewaysfigure}          % fig 10: bs special casing
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
      if(i_bs_flag) {
	/* examine old and new pop. and take the best NP members
	 * into next generation */
	for (i = 0; i < i_NP; i++) {
	  for (j = 0; j < i_D; j++) 
	    gta_popP[i][j] = gta_oldP[i][j];
	  gta_popC[i] = gta_oldC[i];
	}
	for (i = 0; i < i_NP; i++) {
	  for (j = 0; j < i_D; j++) 
	    gta_popP[i_NP+i][j] = gta_newP[i][j];
	  gta_popC[i_NP+i] = gta_newC[i];
	}
	i_len = 2 * i_NP;
	step = i_len;  /* array length */
	while (step > 1) {
	  step /= 2;   /* halve the step size */
	  do {
	    done = 1;
	    bound  = i_len - step;
	    for (j = 0; j < bound; j++) {
		i = j + step + 1;
		if (gta_popC[j] > gta_popC[i-1]) {
		    for (k = 0; k < i_D; k++) 
		      tempP[k] = gta_popP[i-1][k];
		    tempC = gta_popC[i-1];
		    for (k = 0; k < i_D; k++) 
		      gta_popP[i-1][k] = gta_popP[j][k];
		    gta_popC[i-1] = gta_popC[j];
		    for (k = 0; k < i_D; k++) 
		      gta_popP[j][k] = tempP[k];
		    gta_popC[j] = tempC;
		      done = 0; 
		      /* if a swap has been made we are not finished yet */
	        }  /* if */
	    }  /* for */
	  } while (!done);   /* while */
	} /*while (step > 1) */
	/* now the best NP are in first NP places in gta_pop, use them */
	for (i = 0; i < i_NP; i++) {
	  for (j = 0; j < i_D; j++) 
	    gta_newP[i][j] = gta_popP[i][j];
	  gta_newC[i] = gta_popC[i];
	}
      } /*i_bs_flag*/
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
	if (i_bs_flag) {	// examine old and new pop. and take the best NP members into next generation 
	    
	    ta_popP.cols(0, i_NP-1) = ta_oldP;
	    ta_popC.rows(0, i_NP-1) = ta_oldC;

	    ta_popP.cols(i_NP, 2*i_NP-1) = ta_newP;
	    ta_popC.rows(i_NP, 2*i_NP-1) = ta_newC;

	    int i_len = 2 * i_NP;
	    int step = i_len, done;	// array length 
	    while (step > 1) {
		step /= 2;   		// halve the step size 
		do {
		    done = 1;
		    int bound  = i_len - step;
		    for (int j = 0; j < bound; j++) {
			int i = j + step + 1;
			if (ta_popC[j] > ta_popC[i-1]) {
			    ta_popP.swap_cols(j, i-1);
			    ta_popC.swap_rows(j, i-1);
			    done = 0;
			}  // if 
		    }  // for 
		} while (!done); // while
	    } // while (step > 1) 
	    ta_newP = ta_popP.cols(0, i_NP-1);	// now the best NP are in first NP places in gta_pop, use them
	    ta_newC = ta_popC.rows(0, i_NP-1);
	} // i_bs_flag
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} case of \code{i\_bs\_flag}}
  \label{fig:deoptim_end}
\end{sidewaysfigure}


\begin{sidewaysfigure}          % fig 11: end of devol()
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
      /* have selected NP mutants move on to next generation */
      for (i = 0; i < i_NP; i++) {
	for (j = 0; j < i_D; j++) 
	  gta_oldP[i][j] = gta_newP[i][j];
	gta_oldC[i] = gta_newC[i];
      }
      /* check if the best stayed the same, if necessary */
      if(i_check_winner)  {
	same = 1;
	for (j = 0; j < i_D; j++)
	  if(t_bestitP[j] != gt_bestP[j]) {
	    same = 0;
	  }
	if(same && i_iter > 1)  {
	  i_xav++;
	  /* if re-evaluation of winner */
	  tmp_best = evaluate(l_nfeval, gt_bestP, par, fcall, rho);
	 
	  /* possibly letting the winner be the average of all past generations */
	  if(i_av_winner)
	    gt_bestC[0] = ((1/(double)i_xav) * gt_bestC[0]) 
	      + ((1/(double)i_xav) * tmp_best) 
              + (gd_bestvalit[i_iter-1] * ((double)(i_xav - 2))/(double)i_xav);
	  else
	    gt_bestC[0] = tmp_best;
	
	}
	else {
	  i_xav = 1;
	}
	
      }
      for (j = 0; j < i_D; j++) 
	t_bestitP[j] = gt_bestP[j];
      t_bestitC = gt_bestC[0];

      if( trace > 0 ) {
        if( (i_iter % trace) == 0 ) {
	  Rprintf("Iteration: %d bestvalit: %f bestmemit:", i_iter, gt_bestC[0]);
	  for (j = 0; j < i_D; j++)
	    Rprintf("%12.6f", gt_bestP[j]);
	  Rprintf("\n");
        }
      }
    } /* end loop through generations */

  /* last population */
  k = 0;
  for (i = 0; i < i_NP; i++) {
    for (j = 0; j < i_D; j++) {
      gd_pop[k] = gta_oldP[i][j];      
      k++;
    }
  }

  *gi_iter = i_iter;

  PutRNGstate();
  UNPROTECT(1);

}
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
        ta_oldP = ta_newP;                      // have selected NP mutants move on to next generation 
        ta_oldC = ta_newC;

        if (i_check_winner)  {                  // check if the best stayed the same, if necessary 
            int same = 1;
            for (int j = 0; j < i_D; j++) {
                if (t_bestitP[j] != t_bestP[j]) {
                    same = 0;
                }
            }
            if (same && i_iter > 1)  {
                i_xav++;
                memcpy(REAL(par), t_bestP.memptr(), Rf_nrows(par) * sizeof(double));      
                double tmp_best = ev->eval(par);// if re-evaluation of winner 
                if (i_av_winner)                //  possibly letting the winner be the average of all past generations 
                    t_bestC = ((1/(double)i_xav) * t_bestC) + ((1/(double)i_xav) * tmp_best) + 
                        (d_bestvalit[i_iter-1] * ((double)(i_xav - 2))/(double)i_xav);
                else
                    t_bestC = tmp_best;
            } else {
                i_xav = 1;
            }
        }
        t_bestitP = t_bestP;

        if ( (i_trace > 0)  &&  ((i_iter % i_trace) == 0) ) {
            Rprintf("Iteration: %d bestvalit: %f bestmemit:", i_iter, t_bestC);
            for (int j = 0; j < i_D; j++)
                Rprintf("%12.6f", t_bestP[j]);
            Rprintf("\n");
        }
    } // end loop through generations 
    
    d_pop = ta_oldP;
    i_iterations = i_iter;
    l_nfeval = ev->getNbEvals();
    PutRNGstate();   
}
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} population processing and return preparation}
  \label{fig:deoptim_end}
\end{sidewaysfigure}


\begin{sidewaysfigure}          % fig 12: evaluate
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
double evaluate(long *l_nfeval, double *param, SEXP par, SEXP fcall, SEXP env)
{
   int i;
   SEXP sexp_fvec, fn;
   double f_result;  

   for (i = 0; i < nrows(par); i++) {
      NUMERIC_POINTER(par)[i] = param[i];
   }
   PROTECT(fn = lang2(fcall, par)); 
      (*l_nfeval)++;  /* increment function evaluation count */

   PROTECT(sexp_fvec = eval(fn, env)); 
   f_result = NUMERIC_POINTER(sexp_fvec)[0];
   
   UNPROTECT(2);
   if(ISNAN(f_result))
     error("NaN value of objective function! \nPerhaps adjust the bounds.");
   
   return(f_result); 
}
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
namespace Rcpp {
    namespace DE {

	class EvalBase { 
	public:
	    EvalBase() : neval(0) {};
	    virtual double eval(SEXP par) = 0;
	    unsigned long getNbEvals() { return neval; }
        protected:
            unsigned long int neval;
	};

	class EvalStandard : public EvalBase {
	public:
	    EvalStandard(SEXP fcall_, SEXP env_) : fcall(fcall_), env(env_) {} 
	    double eval(SEXP par) {
		neval++;
		return defaultfun(par);
	    }
	private:
	    SEXP fcall, env;
	    double defaultfun(SEXP par) { 		// essentialy the same as the old evaluate
		SEXP fn = ::Rf_lang2(fcall, par); 	// this could be done with Rcpp 
		SEXP sexp_fvec = ::Rf_eval(fn, env);	// but is still a lot slower right now
		double f_result = REAL(sexp_fvec)[0];
		if (ISNAN(f_result)) 
		    ::Rf_error("NaN value of objective function! \nPerhaps adjust the bounds.");
		return(f_result); 
	    }
	};

	typedef double (*funcPtr)(SEXP);
	class EvalCompiled : public EvalBase {
	public:
	    EvalCompiled( Rcpp::XPtr<funcPtr> xptr ) {
		funptr = *(xptr);
	    };
	    EvalCompiled( SEXP xps ) {
		Rcpp::XPtr<funcPtr> xptr(xps);
		funptr = *(xptr);
	    };
	    double eval(SEXP par) {
		neval++;
		return funptr(par);
	    }
	private:
	    funcPtr funptr;
	};

    }
}
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{evaluate()} function versus Evaluation classes permitting
    \proglang{R} and \proglang{C++} objective functions}
  \label{fig:deoptim_end}
\end{sidewaysfigure}


\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
