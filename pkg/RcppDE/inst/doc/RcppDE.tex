%% use JSS class but for now with nojss option
\documentclass[nojss,shortnames,article]{jss}
\usepackage{rotating}
%\usepackage{float}
\usepackage{flafter}
\usepackage{booktabs}

\author{Dirk Eddelbuettel\\Debian Project} % \And Second Author\\Plus Affiliation}
\title{From \pkg{DEoptim} to \pkg{RcppDE}: \\
  A case study in porting from \proglang{C} to \proglang{C++} \\
  using \pkg{Rcpp} and \pkg{RcppArmadillo}}

\Plainauthor{Dirk Eddelbuettel} % , Second Author} %% comma-separated
\Plaintitle{DEoptim: A case study in porting to C++ and Rcpp}
\Shorttitle{A case study in porting to C++ and Rcpp}

\Abstract{
  \noindent
  \pkg{DEoptim} \citep{MullenArdiaEtAl:2009:DEoptim,ArdiaBoudtCarlEtAl:2010:DEoptim,CRAN:DEoptim}
  provides differential evolution optimisation for 
  \proglang{R}.  It is based on an implementation by Storn
  \citep{PriceStornLampinen:2006:DE} and was originally implemented as an
  interpreted \proglang{R} script. It was then rewritten in ANSI C which
  resulted in a much improved performance.

  The present paper introduces another implementation. This version is
  written in \proglang{C++} based on the \pkg{Rcpp} package \citep{CRAN:Rcpp}
  which provides tools for a more direct integration of \proglang{R} objects at the \proglang{C++}
  level---and vice versa. It also uses the \pkg{RcppArmadillo} package \citep{CRAN:RcppArmadillo}
  which provides an interface from \proglang{R} to the \pkg{Armadillo} linear algebra
  package written in \proglang{C++} by Sanderson \citep{Sanderson:2010:Armadillo}.
}

\Keywords{\pkg{Rcpp}, \pkg{RcppArmadillo}, \pkg{DEoptim}, differential
  evolution, genetic algorithm} %% at least one keyword must be supplied
\Plainkeywords{Rcpp, RcppArmadillo, DEoptim, differential evolution, genetic algorith} %% without formatting

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

\Address{
  Dirk Eddelbuettel \\
  Debian Project \\
  River Forest, IL, USA\\
  %% Telephone: +43/1/31336-5053
  %% Fax: +43/1/31336-734
  E-mail: \email{edd@debian.org}\\
  URL: \url{http://dirk.eddelbuettel.com}
}

%% need no \usepackage{Sweave.sty}

% ------------------------------------------------------------------------

\begin{document}

\section{Introduction}

\pkg{DEoptim}
\citep{MullenArdiaEtAl:2009:DEoptim,ArdiaBoudtCarlEtAl:2010:DEoptim,CRAN:DEoptim}
provides differential evolution optimisation for the \proglang{R} language
and statistical environement.  Differential optimisation is one of several
evolutionary computing approaches; genetic algorithns and simulated annealing
are two other ones.  Differential optimisation is reasonably close to genetic
algorithms but differs in one key aspect: parameter values are encoded as
floating point values (rather than sequences of binary digits) which makes it
particular suitable for real-valued optimisation problems.

\pkg{DEoptim} is based on an implementation by Storn
\citep{PriceStornLampinen:2006:DE}. It was originally implemented as an
(interpreted) \proglang{R} script before being rewritten in (compiled)
\proglang{C} which resulted in a much improved performance. \pkg{DEoptim} is
being used to optimise problems from a wide range of problem domains ranging
from crystallography \citep{MullenKrayzmanLevin:2010:Atomic} to agricultural
economics \citep{BoernerHigginsKantelhardt:2007:Rainfall} and computational
finance \citep{BoudtPetersonCarl:2008:HFPortfolio}. It is also being used by
two other CRAN packages for R: \pkg{micEconCES} \citep{CRAN:micEconCES} and
\pkg{selectMeta} \citep{CRAN:selectMeta}.

The present paper introduces the \proglang{R} package \pkg{RcppDE}. It
provides another iteration as far as implementations of differential
evolution go. This new version is based very closely on \pkg{DEoptim} but
written in \proglang{C++}. The implementation employs the \pkg{Rcpp} package
\citep{CRAN:Rcpp} which provides tools for a more direct integration of
\proglang{R} objects at the \proglang{C++} level---and vice versa. It also
uses the \pkg{RcppArmadillo} package \citep{CRAN:RcppArmadillo} which
provides an interface from \proglang{R} to the \pkg{Armadillo} linear algebra
package written in \proglang{C++} by Sanderson
\citep{Sanderson:2010:Armadillo}.

The code structure descends directly from the current \pkg{DEoptim} by
\cite{CRAN:DEoptim}.  The conversion to \proglang{C++} was undertaken to see
whether one or more of the goals \textsl{shorter}, \textsl{easier}  and
\textsl{faster} could be achieved by switching the implementation
language. These goals were loosely defined as follows:
\begin{itemize}
\item[shorter] replacing code that is by necessity somewhat verbose when
  written in \proglang{C} with more compact code written in \proglang{C++}:
  an example would be copying of a matrix which is implemented as a dual loop
  copying each element---whereas \proglang{C++} allows us to use a single
  (overloaded) \verb|+| operator and hence a single statement;
\item[easier] this may appear as a corollary to the previous point but really
  covers other aspects such as the automatic type conversion offered by
  \pkg{Rcpp} as well as the automatic memory management: by replacing
  allocation and freeing of heap-based dynamic memory, a consistent source of
  programmer error would be elimnated---plus we are not trying `short and
  incomprehensible' in the APL-sense but aim for possible improvements on
  \textsl{both} the length and the ease of comprehension without trading one
  off against the other;
\item[faster] this may be a bit more of a conjecture as ultimately,
  \proglang{C++} and \proglang{C} can be expected to be roughly equivalent
  given matching compiler versions etc; however gains maybe be expected from
  replacing a copying operation of a block of adjacent memory cells with a
  single \verb|memcpy()| call done behind the scenes; \pkg{RcppArmadillo}
  also offers further possible gains from template metaprogramming which can
  result in the elimination of temporary object in complex expression where,
  loosely speaking, compile-time effort is substituted to gain later run-time
  performance. 
\end{itemize}

This paper is organised as follows. The next sections describes the structure
of \pkg{DEoptim} which \pkg{RcppDE} shadows closesly. The following two
section compare differences at the \proglang{R} and \proglang{C++} level,
respectively. Next, changes in auxiliarry files are discussed before a
short section reviews perfomance changes. A summary concludes. The
appendix contains a list of figures contrasting the two implementations.

\section[DEoptim structure]{\pkg{DEoptim} structure}

\pkg{DEoptim} is a straightforward and well-implemented package. Its
functionality is provided by three \proglang{R} files, as well as three
\proglang{C} files.

In the transition \pkg{DEoptim} from to \pkg{RcppDE} many more changes were
made to the \proglang{C} files: besides the obvious porting from \proglang{C}
to \proglang{C++}, several internal code changes were made.  We discuss these
changes below.  An important point to note is that the overall architecture
and API remain as unchanged as possible.  
%
On the other hand, very few changes were required at the \proglang{R}
level. The user-facing side of \pkg{DEoptim} persists virtually unchanged
(with one or two changes discussed below).  

Because of the dominant number of changes at the level of the compiled
languages, we discuss the structure, and later on changes, of this part first
before turning to the \proglang{R} side.

\subsection[C / C++ structure and changes]{\proglang{} / \proglang{C++} structure and changes}

\begin{table}[htb]
  \begin{center}
    \begin{tabular}{lrclr}
      \toprule
      \multicolumn{2}{c}{\pkg{DEoptim}} & & \multicolumn{2}{c}{\pkg{RcppDE}} \\
      File  & Functions    & & File  & Functions\\ 
      %                      \cmidrule{1-2,3-4} \\
      \midrule 
      \verb|de4_0.c| & \verb|DEoptimC()| & & \verb|deoptim.cpp| & \verb|DEoptim()| \\
                      & \verb|devol()|    & & \verb|devol.cpp|    & \verb|devol()| \\
                      & \verb|permute()|  & & \verb|permute.cpp| & \verb|permute()| \\[6pt]
      \verb|evaluate.c|&  \verb|evaluate()| & & & \\[6pt]
        &             & & \verb|evaluate.h|& \phantom{X} \verb|EvalBase class|  \\[6pt]
      \verb|get_element.c|\phantom{X} &  \verb|getListElement()| & \phantom{X} & & \\
      \bottomrule
    \end{tabular}
    \caption{Source file organisation for \proglang{C} files in \pkg{DEoptim}}
    \label{tab:Cfiles}
  \end{center}
\end{table}

Table~\ref{tab:Cfiles} lists the \proglang{C} and \proglang{C++}
files in \pkg{DEoptim} and \pkg{RcppDE}, respectively. 
The large file \verb|de4_0.c| has been split into three files: one each for
the core functions \verb|DEoptim()| (which is called from \proglang{R}),
\verb|devol()| (which is the core differential evolution optimisation
routine) and \verb|permute()| (which is a helper function used to shuffle
indices).  

The evalution function has been replaced by a base class and two virtual
classes. These can now use of an objective function written in \proglang{R}
(as in \pkg{DEoptim}) as well as one written in \proglang{C++} which can lead
to substantial speed improvements.  Section~\ref{sec:Cppchanges} discusses
these changes in more detail.


\subsection[R structure and changes]{\proglang{R} structure and changes}

Table~\ref{tab:Rfiles} lists the files and corresponding key functions.  Very
few changes has to made for \pkg{RcppDE} as keeping the interface compatible
was an important goal. As can be seen from table~\ref{tab:Rfiles}, no files
or functions were added.  A more detailed comparison follow below in
section~\ref{sec:Rchanges}.

\begin{table}[tb]
  \begin{center}
    \begin{tabular}{lr}
      \toprule
      File                                     & Functions \\ 
      \midrule
%                                                \cmidrule{2}
      \verb|DEoptim.R| \phantom{XXXXX}        & \verb|DEoptim()| \\
                                                & \verb|DEoptim.control()| \\[6pt]
      \verb|methods.R|                         & \verb|summary.DEoptim()| \\
                                                & \verb|plot.DEoptim()| \\[6pt]
      \verb|zzz.R|                             & \verb|.onLoad()| \\
      \bottomrule
    \end{tabular}
    \caption{Source file organisation for \proglang{R} files in \pkg{DEoptim}
    and \pkg{RcppDE}}
    \label{tab:Rfiles}
  \end{center}
\end{table}


\section[C / C++ changes]{\proglang{C} / \proglang{C++} changes}
\label{sec:Cppchanges}

In this section, we will look at the changes at the \proglang{C} /
\proglang{C++} level. Figures~\ref{fig:deoptim_start} to
\ref{fig:deoptim_end} contain the code the highest-level \proglang{C++}
function: \verb|DEoptim()| (which we renamed from \verb|DEoptim_C()| as there
is no need for a different name at the \proglang{C} level relative to
\proglang{R}). This is followed by figures~\ref{fig:devol_start} to
\ref{fig:devol_return} on the main worker function \verb|devol()| before
figure~\ref{fig:evaluate_fun} compares the objective function evaluation of
as the last element at the \proglang{C} / \proglang{C++} level.

\subsection[de4_0.c and deoptim.cpp]{\code{de4\_0.c} and \code{deoptim.cpp}}

The \verb|DEoptim()| function (renamed from \verb|DEoptim_C()| as there is no need for a different
name at the \proglang{C} level relative to \proglang{R}) is the entry point
from \proglang{R}. It receives parameters, sets up the call of \verb|devol()|
and then prepares the return values. 

\paragraph{Part 1: Start of \texttt{DEoptim()}} The first part concerns
itself with receiving parameters from \proglang{R};
figure~\ref{fig:deoptim_start} displays this. The pure mechanics of passing and
receiving parameters from \proglang{R} are easier thanks to logic provided by
the \pkg{Rcpp} package:
\begin{enumerate}
\item Figure~\ref{fig:deoptim_start} illustrates this point: Panel B (with code
  using \proglang{C++}) appears to be about half the size of panel A but this
  due in part to bringing comments on the same line as code. On the other
  hand, we save for example the declaration of ten \texttt{SEXP} variables as
  \pkg{Rcpp} objects can be converted directly to \texttt{SEXP} type.
\item Instead of using a mix of macros like \verb|NUMERIC_VALUE|,
  \verb|INTEGER_VALUE|, \texttt{NUMERIC\_POINTER} and so on, we have a
  consistent use of the \pkg{Rcpp} template function \verb|as| with template
  types corresponding to base typed \verb|int|, \verb|double| etc. Also of
  note is how one matrix object (\texttt{initialpom} for seeding a first
  population of parameter values) is initialized directly from a parameter.
\item Paremeter lookup is by a string value but done using the \pkg{Rcpp} lookup
  of elements in the \verb|list| type (which corresponds to the \proglang{R}
  list passed in) rather than via a (functionally similar but ad-hoc) function
  \verb|getListElement| that hence is not longer needed in \pkg{RcppDE}.
\item Here as in later code examples, care was taken to ensure that variable
  names and types correpond closely between both variants.
\end{enumerate}

\paragraph{Part 2: Middle of \texttt{DEoptim()}} The second part,
displayed in figure~\ref{fig:deoptim_memory}, allocates dynamic memory for
both parameters returned to \proglang{R} as well as for temporary objects
required to store the results of intermediate computations.  Again, panel A
shows the \proglang{C} code from \pkg{DEoptim} whereas panel B displays the
\proglang{C++} code from \pkg{RcppDE}.  One difference becomes immediately apparent: the lack
of proper matrix or vector types in \proglang{C}. We use the classes from the
\pkg{Armadillo} \proglang{C++} library written by
\cite{Sanderson:2010:Armadillo} and provided via the \proglang{R} package
\pkg{Armadillo} by \citet{CRAN:RcppArmadillo}.
\begin{enumerate}
\item Matrix objects are created in \proglang{C} by first allocating a vector
  of pointers to pointers, which is followed by a loop in which each each
  column is allocated as vector of approrpriate length.
\item In \proglang{C++}, allocating a matrix is a single statement. Memory is
  managed by reference counting and is freed when objects go out of
  scope. This removes a \textsl{significant} portion of programmer errors.
\item Another subtle difference is in the allocations of the container
  holding different population snapshots, here called \texttt{d\_storepop}:
  \pkg{Rcpp} lets us create a list object in which we store matrices, just as
  would in \proglang{R} whereas the \proglang{C} construct is much more
  complicated as we will see below.
\item A subtle point discussed more below is that \pkg{RcppDE} stores
  population members column-wise rather than row-wise. Whereas matrices on the
  left in panel A have dimension $n \times k$, we allocate them as $k \times
  n$ matrices in panel B.
\end{enumerate}

\paragraph{Part 3: End of \texttt{DEoptim()}} The third and last part of
\verb|DEoptim()| covers the actual call of the worker function \verb|devol()|
and the preparation of return values for \proglang{R}. As
figure~\ref{fig:deoptim_end} shows, this section realized a significant
reduction in source code size.

\begin{enumerate}
\item The \verb|devol()| function is called: as we aim to maintain
  interfaces, the call is unchanged between both approaches shown in
  figure~\ref{fig:deoptim_end}.
\item The code following the function call is very different.  The new
  version is shorter for a number of reasons:
  \begin{enumerate}
  \item No need to create new temporary variables just to convert to
    \texttt{SEXP} types for return to \proglang{R} as the \pkg{Rcpp} package takes
    care of this: seamless conversion back to \proglang{R} is a key feature.
  \item No need to allocate memory for new temporary variables (as we do not
    need these variables, and even if we did memory allocation would be implicit).
  \item No need to \texttt{PROTECT} and later \texttt{UNPROTECT} such dynamic
    memory allocations (because this is handled automatically behind the scenes).
  \item No need for an explicit new list object to hold the eight return variables.
  \item No need to explicitly assign names for these eight return
    variables; this done implicitly while we create the returned list object.
  \end{enumerate}
\item Rather, a mere two statements are executed: the call to \verb|devol()|
  followed by single call to create a return object as a list with named
  elements which are simply inserted---just like we would in \proglang{R} itself.
\item The remaining code takes care of exception handling by providing to
  \verb|catch()| branches. These either forward a recognised exception to
  \proglang{R}, or (in the case of an unrecognised exception) signal a
  generic error.
\end{enumerate}

In sum, we see how a number of (possibly small) enhancements taken together
permit us to write a function which is considerably shorter and easier to read, yet
fully equivalent in terms of its functionality.

\subsection[de4_0.c and devol.cpp]{\code{de4\_0.c} and \code{devol.cpp}}

The \verb|devol()| function is the key part of the \pkg{DEoptim}
implementation. It is also by far the largest function.  We will discuss it
again in different sections, each corresponding to one figure ranging from
figure~\ref{fig:devol_start} to figure~\ref{fig:devol_return}.

\paragraph{Part 1: Start of \texttt{devol()}} The first part concerns the
beginning of the \verb|devol()|. The display (in
figure~\ref{fig:devol_start}) of panels A and B differs mostly in minor
ascpects:
\begin{enumerate}
\item The \proglang{C} version contains a declaration of a number of loop
  variable that are either not needed at all in the \proglang{C++} version,
  or declared locally.
\item The urn depth is defined as a \proglang{C} macro and a constant
  variable, respectively.
\item The \proglang{C++} version has an additional short block to set up the
  proper evaluation class for the user supplied function, depending on
  whether an external pointer object is passed (in which case we expect a
  compiled functin) or not in which case an \proglang{R} routine is used,
  just like in \pkg{DEoptim}.
\item The \texttt{sortIndex} vector is filled with index only in case
  strategy six has been selected as it is not used otherwise.
\end{enumerate}

\paragraph{Part 2: Initializations in \texttt{devol()}} The second part of
\verb|devol()| deals with the creation and initialization of a number of
variables.  The \proglang{C} language code in panel A is vastly more verbose
and longer than the \proglang{C++} code in panel B. As shown in
figure~\ref{fig:devol_init}, key differences are:
\begin{enumerate}
\item Initialization of matrices to zero values uses two explicit loops in
  the \proglang{C} version.\footnote{The \texttt{memset()} function could be
    used in the \proglang{C} version ot avoid the loops for a direct
    performance gain.}  In \proglang{C++}, we simply use the member function
  \verb|zeros()| provided by the \pkg{Armadillo} library.
\item In panel B for the \proglang{C++} case, the initial population in
  variable \texttt{initialpopm} is transposed in the \proglang{C++}
  example. We keep each population as a \textsl{column} rather than a
  \textsl{row} as memory can generally be accessed faster column-wise.
\item The actual initialization of the first population is very comparable;
  in particular the \proglang{R} random number generator is called in the
  exact same sequence so that results are in fact identical.
\item The initial population evaluation occurs with a call to
  \verb|evaluate()| in the original version, and a call of the member
  function of the evaluation class which will call either the supplied
  compiled function, or the supplied \proglang{R} functions.
\end{enumerate}

\paragraph{Part 3: Iteration loop setup and start of population loop in \texttt{devol()}} 

The next part of \verb|devol()|, shown in
figure~\ref{fig:devol_iter}, is already inside the large outer loop over all iterations.

Similar to the discussion above, the new code is shorter in large part of
more compact matrix expressions. Other difference are:
\begin{enumerate}
\item Intermediate populations are stored directly in a list, after being
  transposed to account for our design choice of operating column-wise. In
  the \proglang{C} code, the matrices are somewhat awkwardly `serialised'
  into a single vector using a counter that incremened position by position.
\item Several other vector copies are excecuted in a single statement rather
  than in an explicit loop.
\item At the beginning of the population loop, a vector is once more stored
  in a temporary variable and the permuation algoritm is called to pick
  suitable indices which will be used next.
\end{enumerate}

\paragraph{Part 4: First four population strategies in  \texttt{devol()}} 

Evaluating each population member based on the user-selected strategies is
detailed in figure~\ref{fig:devol_first_four}. There are only fairly minor differences
between both version as shown by panels A and B:
\begin{enumerate}
\item Instead of \verb|if/else| branches, the new version uses a
  \verb|switch| statement.
\item The case-invariant initialization of \verb|k| has been moved before the
  block.
\end{enumerate}

\paragraph{Part 5: Remaining three population strategies in  \texttt{devol()}} 

For the three remaining strategies, the code in panels A and B of
figure~\ref{fig:devol_other_three} is similar to the code in
\ref{fig:devol_first_four}.

\paragraph{Part 6: End of population loop in  \texttt{devol()}} 

Figure~\ref{fig:devol_end_pop} contains two fairly short segments that are
entered once within each iteration ater the loop over all population elements
has finished.  The two code segments in panels A and B of
figure~\ref{fig:devol_end_pop}  are fairly equivalent, with the one
difference once again the element-by-element copy of vector elements (in
\proglang{C}) versus the single statement using \proglang{C++} objects.

\paragraph{Part 7: Special case of \texttt{bs} flag in  \texttt{devol()}} 

Simlarly, figure~\ref{fig:devol_bs_flag} once more shows difference chiefly
due to the way interim solutions are copied. Panel A has a full nine loops
for copying vector or matrix elements which are not needed in panel B.  We
should note that this code is executed only when the user has changed the
default value of false for the \texttt{bs} option in the control list for
\texttt{DEoptim()}. 

\paragraph{Part 8: End  of  \texttt{devol()}} 

Figure~\ref{fig:devol_return} contains the final portion of the
\verb|devol()| function. The population and its fitness value are saved. If
the \texttt{checkWinner} of the control structure has been changed from the
default value of false, a possible re-evaluation of the best population
occurs and values are updated.  

Next, if tracing is enabling and the iteration counter has a matching value,
updates are printed before a few state variables are updated and the function
returns after restoring the state of the random number generator.


\subsection[Evaluation functions in R and C++]{Evaluation functions in \proglang{R} and \proglang{C++}}

Figure~\ref{fig:evaluate_fun} is the rare exception: the new code from
\pkg{RcppDE} is much longer than old code it replaces.  This is due to the
main extension between \pkg{DEoptim} and \pkg{RcppDE} it provides: the
ability to supply not only an \proglang{R} function to describe the objective
function to be minimmized---but also a compiled function.

This is implemented by means of so-called abstract base class
\texttt{EvalBase}. This is an empty class no containing code, but providing
an interface (containing of two public functions \texttt{eval()} and
\texttt{getNbEvals()}) that is then filled in.  
Here, we have two classed deriving from the abstract base class: one each for
the \proglang{R} and the \proglang{C++} function.  

The class \texttt{EvalStandard} in panel B correspond most closely to the
normal \texttt{evaluate()} in panel A. A function call with a set of
parameters is prepared and the evaluated in an environment. Here, the
function and the environment are supplied once at the beginning---and hence
used to instantiate the class.  Each evaluation then brings a new parameter
vector. 

The class \texttt{EvalCompiled} does the same, but not for the compiled
function that we access via an external pointer. The support for external
pointer types via type \texttt{XPtr} class in \pkg{Rcpp} was instrumental in
implementing this.  Similar to the standard case, the function is supplied at
the beginning to instantiate the class.  Later, on each evaluation call a new
parameter vector is supplied.

\section[R changes]{\proglang{R} changes}
\label{sec:Rchanges}

Figures~\ref{fig:fig_R_DEoptim1} and \ref{fig:fig_R_DEoptim2}
display the main \proglang{R} function \texttt{DEoptim()}.
A few changes have been made:
\begin{enumerate}
\item Population matrices are passed from \proglang{C++} to \proglang{R} as
  matrix objects; no copy or rearrangement has to be undertaken.  This saves
  a block of code at the top of panel B in figure~\ref{fig:fig_R_DEoptim2}.
  Similarly, we do not have cast the population matrix as we already obtain a
  matrix. 
\item \pkg{DEoptim} support variable arguments in the \texttt{R} function.
  For symmetry with the compiled function, we support just a standard
  vector.  However, the environment in which the function and parameters are
  evaluated can also be supplied by the user (whereas \pkg{DEoptim} always
  creates a new environment.
\end{enumerate}

\section{Auxiliary files}

TODO tests/compTests.R

TODO Demo files
TODO scripts/* using demo

\section{Performance}

TODO just in R

TODO compiled

\section{Summary}

\bibliography{RcppDE}


\section*{Appendix}

%% C++ functions

\begin{sidewaysfigure}          % fig 1: beginning of DEoptimC / DEoptim
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
SEXP DEoptimC(SEXP lower, SEXP upper, SEXP fn, SEXP control, SEXP rho)
{
  int i, j;

  /* External pointers to return to R */
  SEXP sexp_bestmem, sexp_bestval, sexp_nfeval, sexp_iter,
    out, out_names, sexp_pop, sexp_storepop, sexp_bestmemit, sexp_bestvalit;

  if (!isFunction(fn))
    error("fn is not a function!");
  if (!isEnvironment(rho))
    error("rho is not an environment!");

  /*-----Initialization of annealing parameters-------------------------*/
  /* value to reach */
  double VTR = NUMERIC_VALUE(getListElement(control, "VTR"));
  /* chooses DE-strategy */
  int i_strategy = INTEGER_VALUE(getListElement(control, "strategy"));
  /* Maximum number of generations */
  int i_itermax = INTEGER_VALUE(getListElement(control, "itermax"));
  /* Number of objective function evaluations */
  long l_nfeval = (long)NUMERIC_VALUE(getListElement(control, "nfeval"));
  /* Dimension of parameter vector */
  int i_D = INTEGER_VALUE(getListElement(control, "npar"));
  /* Number of population members */
  int i_NP = INTEGER_VALUE(getListElement(control, "NP"));
  /* When to start storing populations */
  int i_storepopfrom = INTEGER_VALUE(getListElement(control, "storepopfrom"))-1;
  /* How often to store populations */
  int i_storepopfreq = INTEGER_VALUE(getListElement(control, "storepopfreq"));
  /* User-defined inital population */
  int i_specinitialpop = INTEGER_VALUE(getListElement(control, "specinitialpop"));
  double *initialpopv = NUMERIC_POINTER(getListElement(control, "initialpop"));
  /* User-defined bounds */
  double *f_lower = NUMERIC_POINTER(lower);
  double *f_upper = NUMERIC_POINTER(upper);
  /* stepsize */
  double f_weight = NUMERIC_VALUE(getListElement(control, "F"));
  /* crossover probability */
  double f_cross = NUMERIC_VALUE(getListElement(control, "CR"));
  /* Best of parent and child */
  int i_bs_flag = NUMERIC_VALUE(getListElement(control, "bs"));
  /* Print progress? */
  int i_trace = NUMERIC_VALUE(getListElement(control, "trace"));
  /* Re-evaluate best parameter vector? */
  int i_check_winner = NUMERIC_VALUE(getListElement(control, "checkWinner"));
  /* Average */
  int i_av_winner = NUMERIC_VALUE(getListElement(control, "avWinner"));
  /* p to define the top 100p% best solutions */
  double i_pPct = NUMERIC_VALUE(getListElement(control, "p"));
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{C} version}
    \tiny 

  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
RcppExport SEXP DEoptim(SEXP lowerS, SEXP upperS, SEXP fnS, SEXP controlS, SEXP rhoS) {
    
    try {
        Rcpp::NumericVector  f_lower(lowerS), f_upper(upperS);          // User-defined bounds
        Rcpp::List           control(controlS);                         // named list of params

        double VTR           = Rcpp::as<double>(control["VTR"]);        // value to reach
        int i_strategy       = Rcpp::as<int>(control["strategy"]);      // chooses DE-strategy
        int i_itermax        = Rcpp::as<int>(control["itermax"]);       // Maximum number of generations
        long l_nfeval        = 0;                                       // nb of function evals (NOT passed in)
        int i_D              = Rcpp::as<int>(control["npar"]);          // Dimension of parameter vector
        int i_NP             = Rcpp::as<int>(control["NP"]);            // Number of population members
        int i_storepopfrom   = Rcpp::as<int>(control["storepopfrom"]) - 1;  // When to start storing populations 
        int i_storepopfreq   = Rcpp::as<int>(control["storepopfreq"]);  // How often to store populations 
        int i_specinitialpop = Rcpp::as<int>(control["specinitialpop"]);// User-defined inital population 
        Rcpp::NumericMatrix initialpopm = Rcpp::as<Rcpp::NumericMatrix>(control["initialpop"]);
        double f_weight      = Rcpp::as<double>(control["F"]);          // stepsize 
        double f_cross       = Rcpp::as<double>(control["CR"]);         // crossover probability 
        int i_bs_flag        = Rcpp::as<int>(control["bs"]);            // Best of parent and child 
        int i_trace          = Rcpp::as<int>(control["trace"]);         // Print progress? 
        int i_check_winner   = Rcpp::as<int>(control["checkWinner"]);   // Re-evaluate best parameter vector? 
        int i_av_winner      = Rcpp::as<int>(control["avWinner"]);      // Average 
        double i_pPct        = Rcpp::as<double>(control["p"]);          // p to define the top 100p% best solutions 

      \end{CodeInput}
    \end{CodeChunk}
 
    \normalsize
    \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
   \end{minipage}
  \caption{Beginning of \code{DEoptim()} \proglang{C/C++} function}
  \label{fig:deoptim_start}
\end{sidewaysfigure}

\begin{sidewaysfigure}          % fig 2: memory allocations
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
  /* Data structures for parameter vectors */
  double **gta_popP = (double **)R_alloc(i_NP*2,sizeof(double *));
  for (int i = 0; i < (i_NP*2); i++) 
    gta_popP[i] = (double *)R_alloc(i_D,sizeof(double));

  double **gta_oldP = (double **)R_alloc(i_NP,sizeof(double *));
  for (int i = 0; i < i_NP; i++) 
    gta_oldP[i] = (double *)R_alloc(i_D,sizeof(double));

  double **gta_newP = (double **)R_alloc(i_NP,sizeof(double *));
  for (int i = 0; i < i_NP; i++) 
    gta_newP[i] = (double *)R_alloc(i_D,sizeof(double));
  
  double *gt_bestP = (double *)R_alloc(1,sizeof(double) * i_D);

  /* Data structures for objective function values associated with
   * parameter vectors */
  double *gta_popC = (double *)R_alloc(i_NP*2,sizeof(double));
  double *gta_oldC = (double *)R_alloc(i_NP,sizeof(double));
  double *gta_newC = (double *)R_alloc(i_NP,sizeof(double));
  double *gt_bestC = (double *)R_alloc(1,sizeof(double));

  double *t_bestitP = (double *)R_alloc(1,sizeof(double) * i_D);
  double *t_tmpP = (double *)R_alloc(1,sizeof(double) * i_D);
  double *tempP = (double *)R_alloc(1,sizeof(double) * i_D);

  int i_nstorepop = ceil((i_itermax - i_storepopfrom) / i_storepopfreq);
  double *gd_pop = (double *)R_alloc(i_NP*i_D,sizeof(double));
  double *gd_storepop = (double *)R_alloc(i_NP,sizeof(double) * i_D * i_nstorepop);
  double *gd_bestmemit = (double *)R_alloc(i_itermax*i_D,sizeof(double));
  double *gd_bestvalit = (double *)R_alloc(i_itermax,sizeof(double));
  int gi_iter = 0;
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{C} version}
    \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
        arma::colvec minbound(f_lower.begin(), f_lower.size(), false);  // convert Rcpp vectors to arma vectors
        arma::colvec maxbound(f_upper.begin(), f_upper.size(), false);
        arma::mat initpopm(initialpopm.begin(), initialpopm.rows(), initialpopm.cols(), false);

        arma::mat ta_popP(i_D, i_NP*2);                                 // Data structures for parameter vectors 
        arma::mat ta_oldP(i_D, i_NP);
        arma::mat ta_newP(i_D, i_NP);
        arma::colvec t_bestP(i_D); 

        arma::colvec ta_popC(i_NP*2);                                   // Data structures for obj. fun. values 
        arma::colvec ta_oldC(i_NP);
        arma::colvec ta_newC(i_NP);
        double t_bestC; 

        arma::colvec t_bestitP(i_D);
        arma::colvec t_tmpP(i_D); 

        int i_nstorepop = ceil((i_itermax - i_storepopfrom) / i_storepopfreq);
        arma::mat d_pop(i_D, i_NP); 
        Rcpp::List d_storepop(i_nstorepop);
        arma::mat d_bestmemit(i_D, i_itermax);       
        arma::colvec d_bestvalit(i_itermax);     
        int i_iter = 0;
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize
    \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{Memory allocation in \code{DEoptim()} \proglang{C/C++} function}
  \label{fig:deoptim_memory}
\end{sidewaysfigure}


\begin{sidewaysfigure}          % fig 3: devol and arguments
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
  /*---optimization--------------------------------------*/
  devol(VTR, f_weight, f_cross, i_bs_flag, f_lower, f_upper, fn, rho, i_trace,
        i_strategy, i_D, i_NP, i_itermax,
        initialpopv, i_storepopfrom, i_storepopfreq, 
        i_specinitialpop, i_check_winner, i_av_winner,
        gta_popP, gta_oldP, gta_newP, gt_bestP,
        gta_popC, gta_oldC, gta_newC, gt_bestC,
        t_bestitP, t_tmpP, tempP,
        gd_pop, gd_storepop, gd_bestmemit, gd_bestvalit,
        &gi_iter, i_pPct, &l_nfeval);
  /*---end optimization----------------------------------*/

  PROTECT(sexp_bestmem = NEW_NUMERIC(i_D));
  for (i = 0; i < i_D; i++) {
    NUMERIC_POINTER(sexp_bestmem)[i] = gt_bestP[i];
  }

  j = i_NP * i_D;
  PROTECT(sexp_pop = NEW_NUMERIC(j));
  for (i = 0; i < j; i++)
    NUMERIC_POINTER(sexp_pop)[i] = gd_pop[i];

  j =  i_nstorepop * i_NP * i_D;
  PROTECT(sexp_storepop = NEW_NUMERIC(j));
  for (i = 0; i < j; i++)
    NUMERIC_POINTER(sexp_storepop)[i] = gd_storepop[i];

  j = gi_iter * i_D;
  PROTECT(sexp_bestmemit = NEW_NUMERIC(j));
  for (i = 0; i < j; i++) 
    NUMERIC_POINTER(sexp_bestmemit)[i] = gd_bestmemit[i];
  j = gi_iter;
  PROTECT(sexp_bestvalit = NEW_NUMERIC(j));
  for (i = 0; i < j; i++)
    NUMERIC_POINTER(sexp_bestvalit)[i] = gd_bestvalit[i];

  PROTECT(sexp_bestval = NEW_NUMERIC(1));
  NUMERIC_POINTER(sexp_bestval)[0] = gt_bestC[0];

  PROTECT(sexp_nfeval = NEW_INTEGER(1));
  //INTEGER_POINTER(sexp_nfeval)[0] = 0;
  INTEGER_POINTER(sexp_nfeval)[0] = l_nfeval;

  PROTECT(sexp_iter = NEW_INTEGER(1));
  INTEGER_POINTER(sexp_iter)[0] = gi_iter;

  PROTECT(out = NEW_LIST(8));
  SET_VECTOR_ELT(out, 0, sexp_bestmem);
  SET_VECTOR_ELT(out, 1, sexp_bestval);
  SET_VECTOR_ELT(out, 2, sexp_nfeval);
  SET_VECTOR_ELT(out, 3, sexp_iter);
  SET_VECTOR_ELT(out, 4, sexp_bestmemit);
  SET_VECTOR_ELT(out, 5, sexp_bestvalit);
  SET_VECTOR_ELT(out, 6, sexp_pop);
  SET_VECTOR_ELT(out, 7, sexp_storepop);
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{C} version}
    \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
  PROTECT(out_names = NEW_STRING(8));
  SET_STRING_ELT(out_names, 0, mkChar("bestmem"));
  SET_STRING_ELT(out_names, 1, mkChar("bestval"));
  SET_STRING_ELT(out_names, 2, mkChar("nfeval"));
  SET_STRING_ELT(out_names, 3, mkChar("iter"));
  SET_STRING_ELT(out_names, 4, mkChar("bestmemit"));
  SET_STRING_ELT(out_names, 5, mkChar("bestvalit"));
  SET_STRING_ELT(out_names, 6, mkChar("pop"));
  SET_STRING_ELT(out_names, 7, mkChar("storepop"));

  SET_NAMES(out, out_names);

  UNPROTECT(10);

  return out;
}
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{C} version (in both columns)}
    \tiny 

    \bigskip
    \phantom{XX}
    \bigskip
    \phantom{XX}
    \bigskip
    \phantom{XX}
    \bigskip


    \begin{CodeChunk}
      \begin{CodeInput}
	// call actual Differential Evolution optimization given the parameters
	devol(VTR, f_weight, f_cross, i_bs_flag, minbound, maxbound, fnS, rhoS, i_trace, i_strategy, i_D, i_NP, 
	      i_itermax, initpopm, i_storepopfrom, i_storepopfreq, i_specinitialpop, i_check_winner, i_av_winner,
	      ta_popP, ta_oldP, ta_newP, t_bestP, ta_popC, ta_oldC, ta_newC, t_bestC, t_bestitP, t_tmpP,
	      d_pop, d_storepop, d_bestmemit, d_bestvalit, i_iter, i_pPct, l_nfeval);

	return Rcpp::List::create(Rcpp::Named("bestmem")   = t_bestP,	// and return a named list with results to R
				  Rcpp::Named("bestval")   = t_bestC,
				  Rcpp::Named("nfeval")    = l_nfeval,
				  Rcpp::Named("iter")      = i_iter,
				  Rcpp::Named("bestmemit") = trans(d_bestmemit),
				  Rcpp::Named("bestvalit") = d_bestvalit,
				  Rcpp::Named("pop")       = trans(d_pop),
				  Rcpp::Named("storepop")  = d_storepop); 

    } catch( std::exception& ex) { 
	forward_exception_to_r(ex); 
    } catch(...) { 
	::Rf_error( "c++ exception (unknown reason)"); 
    }
    return R_NilValue;
}
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize 
    \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{DEoptim()} call of \code{devol()} and return of results to \proglang{R}}
  \label{fig:deoptim_end}
\end{sidewaysfigure}



\begin{sidewaysfigure}          % fig 4: devol and arguments
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
void devol(double VTR, double f_weight, double f_cross, int i_bs_flag,
    double *lower, double *upper, SEXP fcall, SEXP rho, int trace, 
    int i_strategy, int i_D, int i_NP, int i_itermax,
    double *initialpopv, int i_storepopfrom, int i_storepopfreq, 
    int i_specinitialpop, int i_check_winner, int i_av_winner,
    double **gta_popP, double **gta_oldP, double **gta_newP, double *gt_bestP,
    double *gta_popC, double *gta_oldC, double *gta_newC, double *gt_bestC,
    double *t_bestitP, double *t_tmpP, double *tempP,
    double *gd_pop, double *gd_storepop, double *gd_bestmemit, double *gd_bestvalit,
    int *gi_iter, double i_pPct, long *l_nfeval)
{

#define URN_DEPTH  5   /* 4 + one index to avoid */

  /* initialize parameter vector to pass to evaluate function */
  SEXP par; PROTECT(par = NEW_NUMERIC(i_D));
  
  int i, j, k, x;  /* counting variables */
  int i_r1, i_r2, i_r3, i_r4;  /* placeholders for random indexes */

  int ia_urn2[URN_DEPTH];
  int i_nstorepop, i_xav;
  i_nstorepop = ceil((i_itermax - i_storepopfrom) / i_storepopfreq);
  
  int popcnt, bestacnt, same; /* lazy cnters */

  double *fa_minbound = lower;
  double *fa_maxbound = upper;
  double f_jitter, f_dither;
 
  double t_bestitC;
  double t_tmpC, tmp_best; 
  
  double initialpop[i_NP][i_D];
  
  /* vars for DE/current-to-p-best/1 */
  int i_pbest;
  int p_NP = round(i_pPct * i_NP);  /* choose at least two best solutions */
      p_NP = p_NP < 2 ? 2 : p_NP;
  int sortIndex[i_NP];              /* sorted values of gta_oldC */
  for(i = 0; i < i_NP; i++) sortIndex[i] = i;

  /* vars for when i_bs_flag == 1 */
  int i_len, done, step, bound;
  double tempC;

  GetRNGstate();

  gta_popP[0][0] = 0;
      \end{CodeInput}
    \end{CodeChunk}
    \normalsize 
    \centering{Panel A: \proglang{C} version}
    \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
void devol(double VTR, double f_weight, double f_cross, int i_bs_flag,
           arma::colvec & fa_minbound, arma::colvec & fa_maxbound, SEXP fcall, SEXP rho, int i_trace,
           int i_strategy, int i_D, int i_NP, int i_itermax, arma::mat & initialpopm, 
	   int i_storepopfrom, int i_storepopfreq, int i_specinitialpop, int i_check_winner, int i_av_winner,
           arma::mat &ta_popP, arma::mat &ta_oldP, arma::mat &ta_newP, arma::colvec & t_bestP, 
           arma::colvec & ta_popC, arma::colvec & ta_oldC, arma::colvec & ta_newC, double & t_bestC,
           arma::colvec & t_bestitP, arma::colvec & t_tmpP, 
           arma::mat &d_pop, Rcpp::List &d_storepop, arma::mat & d_bestmemit, arma::colvec & d_bestvalit,
           int & i_iterations, double i_pPct, long & l_nfeval) {

    Rcpp::DE::EvalBase *ev = NULL; 		// pointer to abstract base class
    if (TYPEOF(fcall) == EXTPTRSXP) { 		// non-standard mode: we are being passed an external pointer
	ev = new Rcpp::DE::EvalCompiled(fcall); // so assign a pointer using external pointer in fcall SEXP
    } else {					// standard mode: env_ is an env, fcall_ is a function 
	ev = new Rcpp::DE::EvalStandard(fcall, rho);	// so assign R function and environment
    }
    const int urn_depth = 5;   			// 4 + one index to avoid 
    Rcpp::NumericVector par(i_D);		// initialize parameter vector to pass to evaluate function 
    arma::icolvec::fixed<urn_depth> ia_urn2; 	// fixed-size vector for urn draws
    arma::icolvec ia_urntmp(i_NP); 		// so that we don't need to re-allocated each time in permute
    arma::mat initialpop(i_D, i_NP); 
    int i_nstorepop = ceil((i_itermax - i_storepopfrom) / i_storepopfreq);
    int p_NP = round(i_pPct * i_NP);  		// choose at least two best solutions 
    p_NP = p_NP < 2 ? 2 : p_NP;
    arma::icolvec sortIndex(i_NP); 		// sorted values of ta_oldC 
    if (i_strategy == 6) {
	for (int i = 0; i < i_NP; i++) 
	    sortIndex[i] = i; 
    }
    GetRNGstate();
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} beginning}
  \label{fig:devol_start}
\end{sidewaysfigure}



\begin{sidewaysfigure}          % fig 5: devol inits
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
  /* initialize initial popuplation */
  for (int i = 0; i < i_NP; i++) {
    for (int j = 0; j < i_D; j++) {
      initialpop[i][j] = 0.0;
    }
  }

  /* initialize best members */
  for (int i = 0; i < i_itermax * i_D; i++)
    gd_bestmemit[i] = 0.0;

  /* initialize best values */
  for (int i = 0; i < i_itermax; i++)
    gd_bestvalit[i] = 0.0;

  /* initialize best population */
  for (int i = 0; i < i_NP * i_D; i++)
    gd_pop[i] = 0.0;

  /* initialize stored populations */
  if (i_nstorepop < 0)
    i_nstorepop = 0;

  for (int i = 0; i < (i_nstorepop * i_NP * i_D); i++)
    gd_storepop[i] = 0.0;
      
  /* if initial population provided, initialize with values */
  if (i_specinitialpop > 0) {
    k = 0;
    
    for (j = 0; j < i_D; j++) {
      for (i = 0; i < i_NP; i++) {
        initialpop[i][j] = initialpopv[k];
        k += 1;
      }
    }
  }

  /* number of function evaluations
   * (this is an input via DEoptim.control, but we over-write it?) */
  *l_nfeval = 0;

  /*------Initialization-----------------------------*/
  for (i = 0; i < i_NP; i++) {
    for (j = 0; j < i_D; j++) {
      if (i_specinitialpop <= 0) { /* random initial member */
        gta_popP[i][j] = fa_minbound[j] +
        unif_rand() * (fa_maxbound[j] - fa_minbound[j]);

      }
      else /* or user-specified initial member */
        gta_popP[i][j] = initialpop[i][j];
    } 
    gta_popC[i] = evaluate(l_nfeval, gta_popP[i], par, fcall, rho);

    if (i == 0 || gta_popC[i] <= gt_bestC[0]) {
      gt_bestC[0] = gta_popC[i];
      for (j = 0; j < i_D; j++)  
        gt_bestP[j]=gta_popP[i][j];
    }
  }
      \end{CodeInput}
    \end{CodeChunk}

    %\normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}

  /*---assign pointers to current ("old") population---*/
  gta_oldP = gta_popP;
  gta_oldC = gta_popC;
  
  /*------Iteration loop--------------------------------------------*/
  int i_iter = 0;
  popcnt = 0;
  bestacnt = 0;
  i_xav = 1;
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{C} version (in both columns)}
    \tiny 

    \bigskip
    \phantom{XX}
    \bigskip
    \phantom{XX}
    \bigskip
    \phantom{XX}
    \bigskip


    \begin{CodeChunk}
      \begin{CodeInput}
    initialpop.zeros();                         // initialize initial popuplation 
    d_bestmemit.zeros();                        // initialize best members
    d_bestvalit.zeros();                        // initialize best values 
    d_pop.zeros();                              // initialize best population
    i_nstorepop = (i_nstorepop < 0) ? 0 : i_nstorepop;
      
    if (i_specinitialpop > 0) {                 // if initial population provided, initialize with values 
        initialpop = trans(initialpopm);        // transpose as we prefer columns for population members here
    }

    for (int i = 0; i < i_NP; i++) {            // ------Initialization-----------------------------
        if (i_specinitialpop <= 0) {            // random initial member 
            for (int j = 0; j < i_D; j++) {
                ta_popP.at(j,i) = fa_minbound[j] + ::unif_rand() * (fa_maxbound[j] - fa_minbound[j]);
            }
        } else {                                // or user-specified initial member 
            ta_popP.col(i) = initialpop.col(i);
        } 
        memcpy(REAL(par), ta_popP.colptr(i), Rf_nrows(par) * sizeof(double));      
        ta_popC[i] = ev->eval(par);
        if (i == 0 || ta_popC[i] <= t_bestC) {
            t_bestC = ta_popC[i];
            t_bestP = ta_popP.unsafe_col(i);
        }
    }

    ta_oldP = ta_popP.cols(0, i_NP-1);          // ---assign pointers to current ("old") population---
    ta_oldC = ta_popC.rows(0, i_NP-1);
  
    int i_iter = 0;                             // ------Iteration loop--------------------------------------------
    int popcnt = 0;
    int i_xav = 1;
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize 
    \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} initializations}
  \label{fig:devol_init}
\end{sidewaysfigure}




\begin{sidewaysfigure}          % fig 6: devol and arguments
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
  /* loop */
  while ((i_iter < i_itermax) && (gt_bestC[0] > VTR))
    {
      /* store intermediate populations */
      if (i_iter % i_storepopfreq == 0 && i_iter >= i_storepopfrom) {
	for (i = 0; i < i_NP; i++) {
	  for (j = 0; j < i_D; j++) {
	    gd_storepop[popcnt] = gta_oldP[i][j];
	    popcnt++;
	  }
	}
      } /* end store pop */
      
      /* store the best member */
      for(j = 0; j < i_D; j++) {
	gd_bestmemit[bestacnt] = gt_bestP[j];
	bestacnt++;
      }
      /* store the best value */
      gd_bestvalit[i_iter] = gt_bestC[0];
      
      for (j = 0; j < i_D; j++) 
        t_bestitP[j] = gt_bestP[j];
      t_bestitC = gt_bestC[0];
      
      i_iter++;
     
      /*----computer dithering factor -----------------*/
      f_dither = f_weight + unif_rand() * (1.0 - f_weight);
      
      /*---DE/current-to-p-best/1 ---------------------------------*/
      if (i_strategy == 6) {
        /* create a copy of gta_oldC to avoid changing it */
        double temp_oldC[i_NP];
        for(j = 0; j < i_NP; j++) temp_oldC[j] = gta_oldC[j];
        
        /* sort temp_oldC to use sortIndex later */
        rsort_with_index( (double*)temp_oldC, (int*)sortIndex, i_NP );
      }

      /*----start of loop through ensemble-------------------------*/
      for (i = 0; i < i_NP; i++) {

	/*t_tmpP is the vector to mutate and eventually select*/
	for (j = 0; j < i_D; j++) 
	  t_tmpP[j] = gta_oldP[i][j];
	t_tmpC = gta_oldC[i];

	permute(ia_urn2, URN_DEPTH, i_NP, i); /* Pick 4 random and distinct */

	i_r1 = ia_urn2[1];  /* population members */
	i_r2 = ia_urn2[2];
	i_r3 = ia_urn2[3];
	i_r4 = ia_urn2[4];
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
    while ((i_iter < i_itermax) && (t_bestC > VTR)) {    // main loop ====================================
        if (i_iter % i_storepopfreq == 0 && i_iter >= i_storepopfrom) {         // store intermediate populations
            d_storepop[popcnt++] = Rcpp::wrap( trans(ta_oldP) );
        } // end store pop 

        d_bestmemit.col(i_iter) = t_bestP;      // store the best member
        d_bestvalit[i_iter] = t_bestC;          // store the best value 
        t_bestitP = t_bestP;
        i_iter++;                               // increase iteration counter
     
        double f_dither = f_weight + ::unif_rand() * (1.0 - f_weight);  // ----computer dithering factor --------------
      
        if (i_strategy == 6) {                  // ---DE/current-to-p-best/1 ------------------------------------------
            arma::colvec temp_oldC = ta_oldC;                           // create copy of ta_oldC to avoid changing it 
            rsort_with_index( temp_oldC.memptr(), sortIndex.begin(), i_NP );    // sort temp_oldC to use sortIndex 
        }

        for (int i = 0; i < i_NP; i++) {        // ----start of loop through ensemble------------------------

            t_tmpP = ta_oldP.col(i);            // t_tmpP is the vector to mutate and eventually select

            permute(ia_urn2.memptr(), urn_depth, i_NP, i, ia_urntmp.memptr()); // Pick 4 random and distinct 
            int k = 0;                          // loop counter used in all strategies below 
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} iteration loop setup and beginning of population loop}
  \label{fig:devol_iter}
\end{sidewaysfigure}


\begin{sidewaysfigure}          % fig 7: devol main loop and top of strat loop
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
	/*===Choice of strategy=======================================================*/
	/*---classical strategy DE/rand/1/bin-----------------------------------------*/
	if (i_strategy == 1) {
	  
	  j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  do {
	    /* add fluctuation to random target */
	    t_tmpP[j] = gta_oldP[i_r1][j] +
	      f_weight * (gta_oldP[i_r2][j] - gta_oldP[i_r3][j]);

	    j = (j + 1) % i_D;
	    k++;
	  }while((unif_rand() < f_cross) && (k < i_D));

	}
	/*---DE/local-to-best/1/bin---------------------------------------------------*/
	else if (i_strategy == 2) {
	 
	  j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  do {
	    /* add fluctuation to random target */
	   
	    t_tmpP[j] = t_tmpP[j] + 
	      f_weight * (t_bestitP[j] - t_tmpP[j]) +
	      f_weight * (gta_oldP[i_r2][j] - gta_oldP[i_r3][j]);
	    j = (j + 1) % i_D;
	    k++;
	  }while((unif_rand() < f_cross) && (k < i_D));

	}
	/*---DE/best/1/bin with jitter------------------------------------------------*/
	else if (i_strategy == 3) {
	 	  
	  j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  do {
	    /* add fluctuation to random target */
	    f_jitter = 0.0001 * unif_rand() + f_weight;
	    t_tmpP[j] = t_bestitP[j] +
	      f_jitter * (gta_oldP[i_r1][j] - gta_oldP[i_r2][j]);
	    
	    j = (j + 1) % i_D;
	    k++;
	  }while((unif_rand() < f_cross) && (k < i_D));

	}
	/*---DE/rand/1/bin with per-vector-dither-------------------------------------*/
	else if (i_strategy == 4) {
		  
	  j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  do {
	    /* add fluctuation to random target */
	    t_tmpP[j] = gta_oldP[i_r1][j] +
	      (f_weight + unif_rand()*(1.0 - f_weight))*
	      (gta_oldP[i_r2][j]-gta_oldP[i_r3][j]);

	    j = (j + 1) % i_D;
	    k++;
	  }while((unif_rand() < f_cross) && (k < i_D));

	}
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
	    // ===Choice of strategy=======================================================
	    switch (i_strategy) {

	    case 1: {				// ---classical strategy DE/rand/1/bin---------------------------------
		int j = static_cast<int>(::unif_rand() * i_D);	// random parameter 
		do {				// add fluctuation to random target 
		    t_tmpP[j] = ta_oldP.at(j,ia_urn2[1]) + f_weight * 
			(ta_oldP.at(j,ia_urn2[2]) - ta_oldP.at(j,ia_urn2[3]));
		    j = (j + 1) % i_D;
		} while ((::unif_rand() < f_cross) && (++k < i_D));
		break;
	    }
	    case 2: {				// ---DE/local-to-best/1/bin-------------------------------------------
		int j = static_cast<int>(::unif_rand() * i_D);	// random parameter 
		do {				// add fluctuation to random target 
		    t_tmpP[j] = t_tmpP[j] + f_weight * (t_bestitP[j] - t_tmpP[j]) + f_weight * 
			(ta_oldP.at(j,ia_urn2[2]) - ta_oldP.at(j,ia_urn2[3]));
		    j = (j + 1) % i_D;
		} while ((::unif_rand() < f_cross) && (++k < i_D));
		break;
	    }
	    case 3: {				// ---DE/best/1/bin with jitter---------------------------------------
		int j = static_cast<int>(::unif_rand() * i_D);	// random parameter 
		do {				// add fluctuation to random target 
		    double f_jitter = 0.0001 * ::unif_rand() + f_weight; 
		    t_tmpP[j] = t_bestitP[j] + f_jitter * (ta_oldP.at(j,ia_urn2[1]) - ta_oldP.at(j,ia_urn2[2]));
		    j = (j + 1) % i_D;
		} while ((::unif_rand() < f_cross) && (++k < i_D));
		break;
	    }
	    case 4: {				// ---DE/rand/1/bin with per-vector-dither----------------------------
		int j = static_cast<int>(::unif_rand() * i_D);	// random parameter 
		do {				// add fluctuation to random target *
		    t_tmpP[j] = ta_oldP.at(j,ia_urn2[1]) + (f_weight + ::unif_rand()*(1.0 - f_weight)) 
			* (ta_oldP.at(j,ia_urn2[2]) - ta_oldP.at(j,ia_urn2[3]));
		    j = (j + 1) % i_D;
		} while ((::unif_rand() < f_cross) && (++k < i_D));
		break;
	    }
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} first four strategy options}
  \label{fig:devol_first_four}
\end{sidewaysfigure}



\begin{sidewaysfigure}          % fig 8: bottom of strat loop
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
	/*---DE/rand/1/bin with per-generation-dither---------------------------------*/
	else if (i_strategy == 5) {
	  
	  j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  do {
	    /* add fluctuation to random target */
	    t_tmpP[j] = gta_oldP[i_r1][j] +
	      f_dither * (gta_oldP[i_r2][j] - gta_oldP[i_r3][j]);
	    
	    j = (j + 1) % i_D;
	    k++;
	  }while((unif_rand() < f_cross) && (k < i_D));
       
	}
	/*---DE/current-to-p-best/1 (JADE)--------------------------------------------*/
	else if (i_strategy == 6) {

          /* select from [0, 1, 2, ..., (pNP-1)] */
          i_pbest = sortIndex[(int)(unif_rand() * p_NP)];
	  
          j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  do {
	    /* add fluctuation to random target */
	    t_tmpP[j] = gta_oldP[i][j] +
              f_weight * (gta_oldP[i_pbest][j] - gta_oldP[i][j]) +
              f_weight * (gta_oldP[i_r1][j]    - gta_oldP[i_r2][j]);
	    
	    j = (j + 1) % i_D;
	    k++;
	  }while((unif_rand() < f_cross) && (k < i_D));

        }
	/*---variation to DE/rand/1/bin: either-or-algorithm--------------------------*/
	else {
	  
	  j = (int)(unif_rand() * i_D); /* random parameter */
	  k = 0;
	  if (unif_rand() < 0.5) { /* differential mutation, Pmu = 0.5 */
	    do {
	      /* add fluctuation to random target */
	      t_tmpP[j] = gta_oldP[i_r1][j] +
		f_weight * (gta_oldP[i_r2][j] - gta_oldP[i_r3][j]);
	      
	      j = (j + 1) % i_D;
	      k++;
	    }while((unif_rand() < f_cross) && (k < i_D));
	  }
	  else {
	    /* recombination with K = 0.5*(F+1) -. F-K-Rule */
	    do {
	      /* add fluctuation to random target */
	      t_tmpP[j] = gta_oldP[i_r1][j] +
		0.5 * (f_weight + 1.0) * (gta_oldP[i_r2][j]
					  + gta_oldP[i_r3][j] - 2 * gta_oldP[i_r1][j]);
	      
	      j = (j + 1) % i_D;
	      k++;
	    }while((unif_rand() < f_cross) && (k < i_D));

	  }
	}/* end if (i_strategy ...*/
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
	    casee 5: {				// ---DE/rand/1/bin with per-generation-dither---------------
		int j = static_cast<int>(::unif_rand() * i_D); 	// random parameter 
		do {				// add fluctuation to random target 
		    t_tmpP[j] = ta_oldP.at(j,ia_urn2[1]) + f_dither 
			* (ta_oldP.at(j,ia_urn2[2]) - ta_oldP.at(j,ia_urn2[3]));
		    j = (j + 1) % i_D;
		} while ((::unif_rand() < f_cross) && (++k < i_D));
		break;
	    }
	    case 6: {				// ---DE/current-to-p-best/1 (JADE)--------------------------
                // select from [0, 1, 2, ..., (pNP-1)] 
		int i_pbest = sortIndex[static_cast<int>(::unif_rand() * p_NP)]; 
		int j = static_cast<int>(::unif_rand() * i_D); 	// random parameter 
		do {				// add fluctuation to random target 
		    t_tmpP[j] = ta_oldP.at(j,i) + f_weight * (ta_oldP.at(j,i_pbest) - ta_oldP.at(j,i)) + 
			f_weight * (ta_oldP.at(j,ia_urn2[1]) - ta_oldP.at(j,ia_urn2[2]));
		    j = (j + 1) % i_D;
		} while ((::unif_rand() < f_cross) && (++k < i_D));
		break;
	    }
	    default: {				// ---variation to DE/rand/1/bin: either-or-algorithm--------
		int j = static_cast<int>(::unif_rand() * i_D); 	// random parameter 
		if (::unif_rand() < 0.5) { 	// differential mutation, Pmu = 0.5 
		    do {			// add fluctuation to random target */
			t_tmpP[j] = ta_oldP.at(j,ia_urn2[1]) + f_weight *
                                        (ta_oldP.at(j,ia_urn2[2]) - ta_oldP.at(j,ia_urn2[3]));
			j = (j + 1) % i_D;
		    } while ((::unif_rand() < f_cross) && (++k < i_D));

		} else { 			// recombination with K = 0.5*(F+1) -. F-K-Rule 
		    do {			// add fluctuation to random target */
			t_tmpP[j] = ta_oldP.at(j,ia_urn2[1]) + 0.5 * (f_weight + 1.0) * 
			    (ta_oldP.at(j,ia_urn2[2]) + ta_oldP.at(j,ia_urn2[3]) - 2 * ta_oldP.at(j,ia_urn2[1]));
			j = (j + 1) % i_D;
		    } while ((::unif_rand() < f_cross) && (++k < i_D));
		}
		break;
	    }
	    } // end switch (i_strategy) ...
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} remaining three strategy options}
  \label{fig:devol_other_three}
\end{sidewaysfigure}




\begin{sidewaysfigure}          % fig 9: remainder of core loop
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
	/*----boundary constraints, bounce-back method was not enforcing bounds correctly*/
	for (j = 0; j < i_D; j++) {
	  if (t_tmpP[j] < fa_minbound[j]) {
	    t_tmpP[j] = fa_minbound[j] +
	      unif_rand() * (fa_maxbound[j] - fa_minbound[j]);
	  }
	  if (t_tmpP[j] > fa_maxbound[j]) {
	    t_tmpP[j] =  fa_maxbound[j] -
	      unif_rand() * (fa_maxbound[j] - fa_minbound[j]);
	  }
	}

	/*------Trial mutation now in t_tmpP-----------------*/
	/* Evaluate mutant in t_tmpP[]*/

	t_tmpC = evaluate(l_nfeval, t_tmpP, par, fcall, rho); 
	
	/* note that i_bs_flag means that we will choose the
	 *best NP vectors from the old and new population later*/
	if (t_tmpC <= gta_oldC[i] || i_bs_flag) {
	  /* replace target with mutant */
	  for (j = 0; j < i_D; j++) 
	    gta_newP[i][j]=t_tmpP[j];
	  gta_newC[i]=t_tmpC;
	  if (t_tmpC <= gt_bestC[0]) {
	    for (j = 0; j < i_D; j++) 
	      gt_bestP[j]=t_tmpP[j];
	    gt_bestC[0]=t_tmpC;
	  }
	} 
	else {
	  for (j = 0; j < i_D; j++) 
	    gta_newP[i][j]=gta_oldP[i][j];
	  gta_newC[i]=gta_oldC[i];
	  
	}
      } /* End mutation loop through pop. */
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
            for (int j = 0; j < i_D; j++) {     // boundary constr., bounce-back meth. not enforcing bounds 
                if (t_tmpP[j] < fa_minbound[j]) {
                    t_tmpP[j] = fa_minbound[j] + ::unif_rand() * (fa_maxbound[j] - fa_minbound[j]);
                }
                if (t_tmpP[j] > fa_maxbound[j]) {
                    t_tmpP[j] = fa_maxbound[j] - ::unif_rand() * (fa_maxbound[j] - fa_minbound[j]);
                }
            }

            // ------Trial mutation now in t_tmpP-----------------
            memcpy(REAL(par), t_tmpP.memptr(), Rf_nrows(par) * sizeof(double));      
            double t_tmpC = ev->eval(par);              // Evaluate mutant in t_tmpP
            if (t_tmpC <= ta_oldC[i] || i_bs_flag) {    // i_bs_flag means will choose best NP later
                ta_newP.col(i) = t_tmpP;                // replace target with mutant 
                ta_newC[i] = t_tmpC;
                if (t_tmpC <= t_bestC) {
                    t_bestP = t_tmpP;
                    t_bestC = t_tmpC;
                }
            } else {
                ta_newP.col(i) = ta_oldP.col(i);
                ta_newC[i] = ta_oldC[i];
            }
        } // End mutation loop through pop., ie the "for (i = 0; i < i_NP; i++)"
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} remainder of population mutation loop}
  \label{fig:devol_end_pop}
\end{sidewaysfigure}


\begin{sidewaysfigure}          % fig 10: bs special casing
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
      if(i_bs_flag) {
	/* examine old and new pop. and take the best NP members
	 * into next generation */
	for (i = 0; i < i_NP; i++) {
	  for (j = 0; j < i_D; j++) 
	    gta_popP[i][j] = gta_oldP[i][j];
	  gta_popC[i] = gta_oldC[i];
	}
	for (i = 0; i < i_NP; i++) {
	  for (j = 0; j < i_D; j++) 
	    gta_popP[i_NP+i][j] = gta_newP[i][j];
	  gta_popC[i_NP+i] = gta_newC[i];
	}
	i_len = 2 * i_NP;
	step = i_len;  /* array length */
	while (step > 1) {
	  step /= 2;   /* halve the step size */
	  do {
	    done = 1;
	    bound  = i_len - step;
	    for (j = 0; j < bound; j++) {
		i = j + step + 1;
		if (gta_popC[j] > gta_popC[i-1]) {
		    for (k = 0; k < i_D; k++) 
		      tempP[k] = gta_popP[i-1][k];
		    tempC = gta_popC[i-1];
		    for (k = 0; k < i_D; k++) 
		      gta_popP[i-1][k] = gta_popP[j][k];
		    gta_popC[i-1] = gta_popC[j];
		    for (k = 0; k < i_D; k++) 
		      gta_popP[j][k] = tempP[k];
		    gta_popC[j] = tempC;
		      done = 0; 
		      /* if a swap has been made we are not finished yet */
	        }  /* if */
	    }  /* for */
	  } while (!done);   /* while */
	} /*while (step > 1) */
	/* now the best NP are in first NP places in gta_pop, use them */
	for (i = 0; i < i_NP; i++) {
	  for (j = 0; j < i_D; j++) 
	    gta_newP[i][j] = gta_popP[i][j];
	  gta_newC[i] = gta_popC[i];
	}
      } /*i_bs_flag*/
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
	if (i_bs_flag) {	// examine old and new pop. and take the best NP members into next generation 
	    
	    ta_popP.cols(0, i_NP-1) = ta_oldP;
	    ta_popC.rows(0, i_NP-1) = ta_oldC;

	    ta_popP.cols(i_NP, 2*i_NP-1) = ta_newP;
	    ta_popC.rows(i_NP, 2*i_NP-1) = ta_newC;

	    int i_len = 2 * i_NP;
	    int step = i_len, done;	// array length 
	    while (step > 1) {
		step /= 2;   		// halve the step size 
		do {
		    done = 1;
		    int bound  = i_len - step;
		    for (int j = 0; j < bound; j++) {
			int i = j + step + 1;
			if (ta_popC[j] > ta_popC[i-1]) {
			    ta_popP.swap_cols(j, i-1);
			    ta_popC.swap_rows(j, i-1);
			    done = 0;
			}  // if 
		    }  // for 
		} while (!done); // while
	    } // while (step > 1) 
	    ta_newP = ta_popP.cols(0, i_NP-1);	// now the best NP are in first NP places in gta_pop, use them
	    ta_newC = ta_popC.rows(0, i_NP-1);
	} // i_bs_flag
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} case of \code{i\_bs\_flag}}
  \label{fig:devol_bs_flag}
\end{sidewaysfigure}


\begin{sidewaysfigure}          % fig 11: end of devol()
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
      /* have selected NP mutants move on to next generation */
      for (i = 0; i < i_NP; i++) {
	for (j = 0; j < i_D; j++) 
	  gta_oldP[i][j] = gta_newP[i][j];
	gta_oldC[i] = gta_newC[i];
      }
      /* check if the best stayed the same, if necessary */
      if(i_check_winner)  {
	same = 1;
	for (j = 0; j < i_D; j++)
	  if(t_bestitP[j] != gt_bestP[j]) {
	    same = 0;
	  }
	if(same && i_iter > 1)  {
	  i_xav++;
	  /* if re-evaluation of winner */
	  tmp_best = evaluate(l_nfeval, gt_bestP, par, fcall, rho);
	 
	  /* possibly letting the winner be the average of all past generations */
	  if(i_av_winner)
	    gt_bestC[0] = ((1/(double)i_xav) * gt_bestC[0]) 
	      + ((1/(double)i_xav) * tmp_best) 
              + (gd_bestvalit[i_iter-1] * ((double)(i_xav - 2))/(double)i_xav);
	  else
	    gt_bestC[0] = tmp_best;
	
	}
	else {
	  i_xav = 1;
	}
	
      }
      for (j = 0; j < i_D; j++) 
	t_bestitP[j] = gt_bestP[j];
      t_bestitC = gt_bestC[0];

      if( trace > 0 ) {
        if( (i_iter % trace) == 0 ) {
	  Rprintf("Iteration: %d bestvalit: %f bestmemit:", i_iter, gt_bestC[0]);
	  for (j = 0; j < i_D; j++)
	    Rprintf("%12.6f", gt_bestP[j]);
	  Rprintf("\n");
        }
      }
    } /* end loop through generations */

  /* last population */
  k = 0;
  for (i = 0; i < i_NP; i++) {
    for (j = 0; j < i_D; j++) {
      gd_pop[k] = gta_oldP[i][j];      
      k++;
    }
  }

  *gi_iter = i_iter;

  PutRNGstate();
  UNPROTECT(1);

}
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
        ta_oldP = ta_newP;                      // have selected NP mutants move on to next generation 
        ta_oldC = ta_newC;

        if (i_check_winner)  {                  // check if the best stayed the same, if necessary 
            int same = 1;
            for (int j = 0; j < i_D; j++) {
                if (t_bestitP[j] != t_bestP[j]) {
                    same = 0;
                }
            }
            if (same && i_iter > 1)  {
                i_xav++;
                memcpy(REAL(par), t_bestP.memptr(), Rf_nrows(par) * sizeof(double));      
                double tmp_best = ev->eval(par);// if re-evaluation of winner 
                if (i_av_winner)         //  poss. letting winner be avg of all past generations 
                    t_bestC = ((1/(double)i_xav) * t_bestC) + ((1/(double)i_xav) * tmp_best) + 
                        (d_bestvalit[i_iter-1] * ((double)(i_xav - 2))/(double)i_xav);
                else
                    t_bestC = tmp_best;
            } else {
                i_xav = 1;
            }
        }
        t_bestitP = t_bestP;

        if ( (i_trace > 0)  &&  ((i_iter % i_trace) == 0) ) {
            Rprintf("Iteration: %d bestvalit: %f bestmemit:", i_iter, t_bestC);
            for (int j = 0; j < i_D; j++)
                Rprintf("%12.6f", t_bestP[j]);
            Rprintf("\n");
        }
    } // end loop through generations 
    
    d_pop = ta_oldP;
    i_iterations = i_iter;
    l_nfeval = ev->getNbEvals();
    PutRNGstate();   
}
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{devol()} population processing and return preparation}
  \label{fig:devol_return}
\end{sidewaysfigure}


\begin{sidewaysfigure}          % fig 12: evaluate
  \begin{minipage}{0.40\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
double evaluate(long *l_nfeval, double *param, SEXP par, SEXP fcall, SEXP env)
{
   int i;
   SEXP sexp_fvec, fn;
   double f_result;  

   for (i = 0; i < nrows(par); i++) {
      NUMERIC_POINTER(par)[i] = param[i];
   }
   PROTECT(fn = lang2(fcall, par)); 
      (*l_nfeval)++;  /* increment function evaluation count */

   PROTECT(sexp_fvec = eval(fn, env)); 
   f_result = NUMERIC_POINTER(sexp_fvec)[0];
   
   UNPROTECT(2);
   if(ISNAN(f_result))
     error("NaN value of objective function! \nPerhaps adjust the bounds.");
   
   return(f_result); 
}
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize \centering{Panel A: \proglang{C} version} \tiny 
  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.56\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
namespace Rcpp {
    namespace DE {

	class EvalBase { 
	public:
	    EvalBase() : neval(0) {};
	    virtual double eval(SEXP par) = 0;
	    unsigned long getNbEvals() { return neval; }
        protected:
            unsigned long int neval;
	};

	class EvalStandard : public EvalBase {
	public:
	    EvalStandard(SEXP fcall_, SEXP env_) : fcall(fcall_), env(env_) {} 
	    double eval(SEXP par) {
		neval++;
		return defaultfun(par);
	    }
	private:
	    SEXP fcall, env;
	    double defaultfun(SEXP par) { 		// essentialy the same as the old evaluate
		SEXP fn = ::Rf_lang2(fcall, par); 	// this could be done with Rcpp 
		SEXP sexp_fvec = ::Rf_eval(fn, env);	// but is still a lot slower right now
		double f_result = REAL(sexp_fvec)[0];
		if (ISNAN(f_result)) 
		    ::Rf_error("NaN value of objective function! \nPerhaps adjust the bounds.");
		return(f_result); 
	    }
	};

	typedef double (*funcPtr)(SEXP);
	class EvalCompiled : public EvalBase {
	public:
	    EvalCompiled( Rcpp::XPtr<funcPtr> xptr ) {
		funptr = *(xptr);
	    };
	    EvalCompiled( SEXP xps ) {
		Rcpp::XPtr<funcPtr> xptr(xps);
		funptr = *(xptr);
	    };
	    double eval(SEXP par) {
		neval++;
		return funptr(par);
	    }
	private:
	    funcPtr funptr;
	};

    }
}
      \end{CodeInput}
    \end{CodeChunk}
    
    \normalsize \centering{Panel B: \proglang{C++} version using \pkg{Rcpp}}
  \end{minipage}
  \caption{\code{evaluate()} function versus Evaluation classes permitting
    \proglang{R} and \proglang{C++} objective functions}
  \label{fig:evaluate_fun}
\end{sidewaysfigure}



%% R functions

\begin{sidewaysfigure}          % fig R1: beginning of DEoptim()
  \begin{minipage}{0.48\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
DEoptim <- function(fn, lower, upper, control = DEoptim.control(), ...) {
  fn1  <- function(par) fn(par, ...)
  if (length(lower) != length(upper))
    stop("'lower' and 'upper' are not of same length")
  if (!is.vector(lower))
    lower <- as.vector(lower)
  if (!is.vector(upper))
    upper <- as.vector(upper)
  if (any(lower > upper))
    stop("'lower' > 'upper'")
  if (any(lower == "Inf"))
    warning("you set a component of 'lower' to 'Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (any(lower == "-Inf"))
    warning("you set a component of 'lower' to '-Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (any(upper == "Inf"))
    warning("you set a component of 'upper' to 'Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (any(upper == "-Inf"))
    warning("you set a component of 'upper' to '-Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (!is.null(names(lower)))
    nam <- names(lower)
  else if (!is.null(names(upper)) & is.null(names(lower)))
    nam <- names(upper)
  else
    nam <- paste("par", 1:length(lower), sep = "")

  ctrl <- do.call(DEoptim.control, as.list(control))
  ctrl$npar <- length(lower)
  if (ctrl$NP < 4) {
    warning("'NP' < 4; set to default value 50\n", immediate. = TRUE)
    ctrl$NP <- 50
  }
  if (ctrl$NP < 10*length(lower)) 
    warning("For many problems it is best to set 'NP' (in 'control') to be at least "
            "ten times the length of the parameter vector. \n", immediate. = TRUE)
  if (!is.null(ctrl$initialpop)) {
    ctrl$specinitialpop <- TRUE
    if(!identical(as.numeric(dim(ctrl$initialpop)), c(ctrl$NP, ctrl$npar)))
      stop("Initial population is not a matrix with dim. NP x length(upper).")
  }
  else {
    ctrl$specinitialpop <- FALSE
    ctrl$initialpop <- 0.0
  }
  ##
  ctrl$trace <- as.numeric(ctrl$trace)
  ctrl$specinitialpop <- as.numeric(ctrl$specinitialpop)
  ctrl$initialpop <- as.numeric(ctrl$initialpop)
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{R} version in \pkg{DEoptim}}
    \tiny 

  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.48\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
DEoptim <- function(fn, lower, upper, control = DEoptim.control(), env, ...) {
  ##fn1  <- function(par) fn(par, ...)
  if (length(lower) != length(upper))
    stop("'lower' and 'upper' are not of same length")
  if (!is.vector(lower))
    lower <- as.vector(lower)
  if (!is.vector(upper))
    upper <- as.vector(upper)
  if (any(lower > upper))
    stop("'lower' > 'upper'")
  if (any(lower == "Inf"))
    warning("you set a component of 'lower' to 'Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (any(lower == "-Inf"))
    warning("you set a component of 'lower' to '-Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (any(upper == "Inf"))
    warning("you set a component of 'upper' to 'Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (any(upper == "-Inf"))
    warning("you set a component of 'upper' to '-Inf'. May imply 'NaN' results", immediate. = TRUE)
  if (!is.null(names(lower)))
    nam <- names(lower)
  else if (!is.null(names(upper)) & is.null(names(lower)))
    nam <- names(upper)
  else
    nam <- paste("par", 1:length(lower), sep = "")
  if (missing(env))
    env <- new.env()

  ctrl <- do.call(DEoptim.control, as.list(control))
  ctrl$npar <- length(lower)
  if (ctrl$NP < 4) {
    warning("'NP' < 4; set to default value 50\n", immediate. = TRUE)
    ctrl$NP <- 50
  }
  if (ctrl$NP < 10*length(lower))
    warning("For many problems it is best to set 'NP' (in 'control') to be at least ten"
            " times the length of the parameter vector. \n", immediate. = TRUE)
  if (!is.null(ctrl$initialpop)) {
    ctrl$specinitialpop <- TRUE
    if(!identical(as.numeric(dim(ctrl$initialpop)), c(ctrl$NP, ctrl$npar)))
      stop("Initial population is not a matrix with dim. NP x length(upper).")
  }
  else {
    ctrl$specinitialpop <- FALSE
    ctrl$initialpop <- matrix(0,1,1)    # dummy matrix
  }
  ##
  ctrl$trace <- as.numeric(ctrl$trace)
  ctrl$specinitialpop <- as.numeric(ctrl$specinitialpop)
      \end{CodeInput}
    \end{CodeChunk}
 
    \normalsize
    \centering{Panel B: \proglang{R} version in \pkg{RcppDE}}
   \end{minipage}
  \caption{First half of \proglang{R} function \texttt{DEoptim()}}
  \label{fig:fig_R_DEoptim1}
\end{sidewaysfigure}

\begin{sidewaysfigure}          % fig R2: second half of DEoptim()
  \begin{minipage}{0.48\linewidth}
    \tiny
    \begin{CodeChunk}
      \begin{CodeInput}
  outC <- .Call("DEoptimC", lower, upper, fn1, ctrl, new.env(),
               PACKAGE = "DEoptim")
  ##
  if (length(outC$storepop) > 0) {
    nstorepop <- floor((outC$iter - ctrl$storepopfrom) / ctrl$storepopfreq)
    storepop <- list()
    cnt <- 1
    for(i in 1:nstorepop) {
      idx <- cnt:((cnt - 1) + (ctrl$NP * ctrl$npar))
      storepop[[i]] <- matrix(outC$storepop[idx], nrow = ctrl$NP, ncol = ctrl$npar,
                         byrow = TRUE)
      cnt <- cnt + (ctrl$NP * ctrl$npar)
      dimnames(storepop[[i]]) <- list(1:ctrl$NP, nam)
    }
  }
  else {
    storepop = NULL
  }

  ## optim
  bestmem <- as.numeric(outC$bestmem)
  names(bestmem) <- nam
  bestval <- as.numeric(outC$bestval)
  nfeval <- as.numeric(outC$nfeval)
  iter <- as.numeric(outC$iter)

  ## member
  names(lower) <- names(upper) <- nam
  bestmemit <- matrix(outC$bestmemit, nrow = iter, 
                      ncol = ctrl$npar, byrow = TRUE)

  dimnames(bestmemit) <- list(1:iter, nam)
  bestvalit <- as.numeric(outC$bestvalit[1:iter])
  pop <- matrix(outC$pop, nrow = ctrl$NP, ncol = ctrl$npar,
                byrow = TRUE)
  storepop <- as.list(storepop)

  outR <- list(optim = list(
              bestmem = bestmem,
              bestval = bestval,
              nfeval = nfeval,
              iter = iter),
            member = list(
              lower = lower,
              upper = upper,
              bestmemit = bestmemit,
              bestvalit = bestvalit,
              pop = pop,
              storepop = storepop))

  attr(outR, "class") <- "DEoptim"
  return(outR)
}
      \end{CodeInput}
    \end{CodeChunk}

    \normalsize 
    \centering{Panel A: \proglang{R} version in \pkg{DEoptim}}
    \tiny 

  \end{minipage}
  \begin{minipage}{0.03\linewidth}
    \phantom{XX}
  \end{minipage}
  \begin{minipage}{0.48\linewidth}
    \tiny

    \begin{CodeChunk}
      \begin{CodeInput}
  outC <- .Call("DEoptim", lower, upper, fn, ctrl, env, PACKAGE = "RcppDE")
  ##
  if (length(outC$storepop) > 0) {
    nstorepop <- floor((outC$iter - ctrl$storepopfrom) / ctrl$storepopfreq)
    ## storepop <- list()
    ## cnt <- 1
    ## for(i in 1:nstorepop) {
    ##   idx <- cnt:((cnt - 1) + (ctrl$NP * ctrl$npar))
    ##   storepop[[i]] <- matrix(outC$storepop[idx], nrow = ctrl$NP, ncol = ctrl$npar,
    ##                      byrow = TRUE)
    ##   cnt <- cnt + (ctrl$NP * ctrl$npar)
    ##   dimnames(storepop[[i]]) <- list(1:ctrl$NP, nam)
    ## }
    storepop <- outC$storepop[1:nstorepop]
    for (i in 1:length(storepop)) dimnames(storepop[[i]]) <- list(1:ctrl$NP, nam)
  }
  else {
    storepop = NULL
  }

  ## optim
  bestmem <- as.numeric(outC$bestmem)
  names(bestmem) <- nam
  bestval <- as.numeric(outC$bestval)
  nfeval <- as.numeric(outC$nfeval)
  iter <- as.numeric(outC$iter)

  ## member
  names(lower) <- names(upper) <- nam
  #bestmemit <- matrix(outC$bestmemit, nrow = iter, ncol = ctrl$npar, byrow = TRUE)
  bestmemit <- outC$bestmemit

  dimnames(bestmemit) <- list(1:iter, nam)
  bestvalit <- as.numeric(outC$bestvalit[1:iter])
  #pop <- matrix(outC$pop, nrow = ctrl$NP, ncol = ctrl$npar, byrow = TRUE)
  pop <- outC$pop
  storepop <- as.list(storepop)

  outR <- list(optim = list(
              bestmem = bestmem,
              bestval = bestval,
              nfeval = nfeval,
              iter = iter),
            member = list(
              lower = lower,
              upper = upper,
              bestmemit = bestmemit,
              bestvalit = bestvalit,
              pop = pop,
              storepop = storepop))

  attr(outR, "class") <- "DEoptim"
  return(outR)
}
      \end{CodeInput}
    \end{CodeChunk}
 
    \normalsize
    \centering{Panel B: \proglang{R} version in \pkg{RcppDE}}
   \end{minipage}
  \caption{Second half of \proglang{R} function \texttt{DEoptim()}}
  \label{fig:fig_R_DEoptim2}
\end{sidewaysfigure}





\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
