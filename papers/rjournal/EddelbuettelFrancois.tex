%% Emacs please consider this:  -*- mode: latex; TeX-master: "RJwrapper.tex"; -*-

\title{Rcpp: Seamless R and C++ integration}
\author{by Dirk Eddelbuettel and Romain Franc\c{c}ois}

\maketitle

\abstract{TBD}

\section{Introduction}

TBD, probably close to last

One idea: call 'classic Rcpp' a \textsl{vertical} approach as it is chiefly
concerned with getting data from R to C++ and back from C++ to R. On the
other hand, 'new Rcpp' is more \textsl{horizontal as well as vertical} as it
also significantly eases access from C++ itself (and to the C++
representation of R objects).  Does that make sense?

\section{Overview}

% [Romain:] the overview is really messy and probably 
% needs a complete rewrite when all other sections are finished
% [Dirk:] Agreed, see Gelman piece. We need more meat on the bones first.

The \pkg{Rcpp} package provides a consistent and comprehensive set 
of C++ classes designed to ease coupling of C++ code
with R. The \code{RObject} class is responsible for 
protecting and releasing its encapsulated R object (\code{SEXP})
from garbage collection. The \code{wrap} set of functions allows
wrapping many C++ built-in types and data structures from the standard
template library into R objects. Similarly, the \code{as} set of 
templated functions allows conversion of R objects back into C++
types, such as \code{std::string}. With recent additions to the 
\pkg{inline} package \citep{cran:inline}, 
C++ code using the classes of the 
\pkg{Rcpp} package can be inlined, compiled, loaded and wrapped 
into an R function without leaving the R console. 
This article reviews some of the design choices of the
\pkg{Rcpp} package, in particular with respect to existing solutions
that deal with coupling R and C++ and shows several use cases.

Writing R Extensions \citep{R:exts} provides extensive 
documentation about the ways to couple R with code written in C. 
Writing such code requires both expertise and discipline from the 
programmer.

The \pkg{Rcpp} package makes extensive use of C++ features (encapsulation, 
constructors, destructors, operator overloading, templates) in order
to hide the complexity of the R API --- without losing its 
efficiency --- under the carpet of object orientation. In addition, 
\pkg{Rcpp} takes advantage of some features of the forthcoming \code{C++0x} 
standard, already supported by recent versions of the GCC.

\subsection{Historical Context}

\pkg{Rcpp} first appeared in 2005 as a contribution to the \pkg{RQuantLib}
package \citep{eddelbuettelkhan09:rquantlib} before being released as a CRAN
package in early 2006. Several releases followed in quick succession; all of
these were under the name \pkg{Rcpp}. The package was then renamed to
\pkg{RcppTemplate} and several more releases followed during 2006 under the
new name.  However, no new releases or updates were made during 2007, 2008
and most of 2009.

Given the continued use of the package, it was revived using the former name
\pkg{Rcpp}. New releases started in November 2008 which include an improved
build and distribution process, additional documentation, and new
functionality---while retaining the existing interface.  This constitutes the
`classic \pkg{Rcpp}' interface (described in the next section)
which will be provided for the forseeable future.

Yet C++ coding standards continued to evolved. So, starting in late 2009 the
codebase was significantly extended and numerous new features were added.
Several of these are described below in the section on the the `New
\pkg{Rcpp}' interface which we also intend to support going forward.

\subsection{Comparison}

Integration of C++ and R has been addressed by several authors; the earliest
published reference is probably \cite{batesdebroy01:cppclasses}.
An unpublished paper by \cite{javagailemanly07:r_cpp} expresses several ideas
that are close to some of our approaches, though not yet fully fleshed out.
%
The \pkg{Rserve} package \citep{cran:Rserve} was another early approach,
going back to 2002. On the server side, \pkg{Rserve} translates R data
structures into a binary serialization format and uses TCP/IP for
transfer. On the client side, objects are reconstructed as instances of Java
or C++ classes that emulate the structure of R objects. 

The packages \pkg{rcppbind} \citep{liang08:rcppbind}, \pkg{RAbstraction}
\citep{armstrong09:RAbstraction} and \pkg{RObjects}
\citep{armstrong09:RObjects} are all implemented using C++ templates.
However, neither one has matured to the point of a CRAN release and it
unclear how much usage these packages are seeing beyond their own authors.
%
CXXR \citep{runnalls09:cxxr} comes to this topic from the other side: 
its aim is to completely refactor R on a stronger C++ foundation. 
CXXR is therefore concerned with all aspects of the R interpreter,
REPL loop, threading --- and object interchange between R and C++ is but one part.
%
Another slightly different angle is offered by
\cite{templelang09:rgcctranslationunit} who uses compiler output for
references on the code in order to add bindings and wrappers.
%
Lastly, the \pkg{RcppTemplate} package \citep{samperi09:rcpptemplate}
recently introduced a few new ideas yet decided to break with the
`classic \pkg{Rcpp}' API.

A critical comparison of these packages that addresses relevant aspects such
API features, performance, useability and documentation would be a welcome
addition to the literature, but is beyond the scope of this article.

\section{Classic Rcpp}
\label{sec:classic_rcpp}

% [Romain:] Why 'at least initial'
% [Dirk:] For 'Classic Rcpp'
% [Romain:] I'd argue it is still the case with the new api
The core focus of \pkg{Rcpp}---particularly for the earlier API described in
this section---has always been on allowing the programmer to add C++-based
functions. We use this term in the standard mathematical sense of providing
results (output) given a set of parameters or data (input). This was
facilitated from the earliest releases using C++ classes for receiving
various types of R objects, converting them to C++ objects and allowing the
programmer to return the results to R with relative use. 

This API therefore supports two typical use cases. First, one can think of
replacing existing R code with equivalent C++ code in order to reap
performance gains.  This case can be conceptually easy as there may not be
(built- or run-time) dependencies on other C or C++ libraries.  It typically
involves setting up data and parameters---the right-hand side components of a
function call---before making the call in order to provide the result that is
to be assigned to the left-hand side. Second, \pkg{Rcpp} facilitates calling
functions provided by other libraries. The use resembles the first case: data
and parameters are passed via \pkg{Rcpp} to a function set-up to call code
from an external library.  

An illustration can be provided using the time-tested example of a
convolution of two vectors. This example is shown in sections 5.2 (for the
\code{.C()} interface) and 5.9 (for the \code{.Call()} interface) of 'Writing
R Extensions' \citep{R:exts}. We have rewritten it here using classes of the
classic \pkg{Rcpp} API:

\begin{example}
#include <Rcpp.h>

RcppExport SEXP convolve2cpp(SEXP a, SEXP b) \{
  RcppVector<double> xa(a);
  RcppVector<double> xb(b);
  int nab = xa.size() + xb.size() - 1;

  RcppVector<double> xab(nab);
  for (int i = 0; i < nab; i++) xab(i) = 0.0;

  for (int i = 0; i < xa.size(); i++)
    for (int j = 0; j < xb.size(); j++) 
       xab(i + j) += xa(i) * xb(j);

  RcppResultSet rs;
  rs.add("ab", xab);
  return rs.getReturnList();
\}
\end{example}

We can highlight several aspects. First, only a single header file
\code{Rcpp.h} is needed to use the \pkg{Rcpp} API.  Second, given two
\code{SEXP} types---the bread-and-butter of all internal R programming---a
third is returned.  Third, both inputs are converted to C++ vector types that
are \textsl{templated} (meaning that a type-indepedent framework can be
applied to create actual vectors of the specified type). Here a standard \code{double}
type is used to create a vector of doubles from the template type.
% [Romain:] I think the previous sentence is confusing, one might think
% that the same vector can hold int and double
% [Dirk:] Better?
% [Romain:] I think so, maybe the (...) should be a footnote
% [Dirk:] Sorry, which '(...)' ?
% [Romain:] (which means ... base types)
% [Dirk:] Ah. Better now? 
Fourth, the usefulness off these classes can be seen when we query the
vectors directly for their size---using the \code{size} member function---in
order to reserved a new result type of appropriate length whereas use based
on C arrays would have required additional parameters for the length of
vectors $a$ and $b$, leaving open the possibility of mismatches between the
actual length and the length reported by the programmer.  Fifth, the
computation itself is straightforward embedded looping just as in the
original examples in the 'Writing R Extensions' manual \citep{R:exts}.
Sixth, a return type (\code{RcppResultSet}) is then prepared as a named
object (something that should be familiar to R programmers) which is then
converted to a list object that is returned.  We should note that the
\code{RcppResultSet} permits the return of numerous (named) objects which can
also be of different types.

We argue that this usage is already easier to read, write and debug than the
C macro-based approach supported by R itself. Possible performance issues and
other potentual limitations will be discussed throughout the article and
reviewed at the end.

\section{Using code `inline'}

Extending R with compiled code also needs to address how to reliably compile,
link and load the code.  While using a package is preferable in the long run,
it may be to heavy a framework for quick explorations.  An alternative is
provided by the \pkg{inline} package \citep{cran:inline} which compiles,
links and loads a C, C++ or Fortran function---directly from the R prompt
using a simple function \code{cfunction}.  It was recently extended to work
with \pkg{Rcpp} by allowing for the use of additional header files and
libraries. This works particularly well with the \pkg{Rcpp} package where
headers and the library are automatically found if the appropriate option
\code{Rcpp} to \texttt{cfunction} is set to true.

% [Romain] : the next paragraph is very confusing
% [Dirk] Is this better?
% [Romain] Not sure. It seems to be only readable backwards. what about a 
%          separate section before 'inline code' just about this
% 
%          it might also be useful to show a quick example of inlining
%          c++ code, for example say that we use it for our unit tests
%          and show an example unit test
% [Dirk] Done in last round
The use of \pkg{inline} is possible as \pkg{Rcpp} can be installed and
updated just like any other R package using \textsl{e.g.} the
\code{install.packages()} function for initial installation as well as
\code{update.packages()} for upgrades.  So even though R / C++ interfacing
would otherwise require source code, the \pkg{Rcpp} library is always provided
ready for use as a pre-built library through the CRAN package mechanism.

The library and header files provided by \pkg{Rcpp} for use by other packages
are installed along with the \pkg{Rcpp} package making it possible for
\pkg{Rcpp} to provide the appropriate \code{-I} and \code{-L} switches needed
for compilation and linking.  So internally, \pkg{inline} makes uses of the
two functions \code{Rcpp:::CxxFlags()} and \code{Rcpp:::LdFlags()} that
provide this information (and which are also used by \code{Makefiles} of
other packages).  Here, however, all this is done behind the scenes and the
user need not worry about compiler or linker options or settings.

The convolution example provided above now can be rewritten for use by
\pkg{inline} as shown here.  The function body is provided by character
variable \code{src}, the function header is defined by the argument
\code{signature}---and we only need to enable \code{Rcpp=TRUE} to obtain a
new function \code{fun} based on the C++ code in \code{src}:
\begin{example}
src <- '
  RcppVector<double> xa(a);
  RcppVector<double> xb(b);
  int nab = xa.size() + xb.size() - 1;

  RcppVector<double> xab(nab);
  for (int i = 0; i < nab; i++) xab(i) = 0.0;

  for (int i = 0; i < xa.size(); i++)
    for (int j = 0; j < xb.size(); j++)
       xab(i + j) += xa(i) * xb(j);

  RcppResultSet rs;
  rs.add("ab", xab);
  return rs.getReturnList();
';
fun <- cfunction(signature(a="numeric", 
                           b="numeric"),
                 src, Rcpp=TRUE)
\end{example}


\section{New \pkg{Rcpp} API}
\label{sec:new_rcpp}

Having discussed the `Classic Rcpp' API and its deployment in the previous
section, we now turn to the `New Rcpp'. The new API is a complete redesign
based on the usage experience of several years of Rcpp deployment, as well as
current C++ design approaches.

% we should include key design aspects here. 
% what are they ?
% - thin wrappers : an RObject only contains a SEXP, no copy
% - RAII
% - member functions define the extent of what is possible to do with an
%   object, instead of the catch all SEXP
% - easy translation between R and c++ types
% - need to talk about implicit conversion somewhere
%
% [Dirk] Sounds great -- give a go!


\subsection{The RObject class}

% [Romain] this needs cleaning
Here, the \code{RObject} class is the base class of all
objects in the extended API of the \pkg{Rcpp} package. An \code{RObject} has only one
data member, the protected \code{SEXP} it encapsulates.  The \code{RObject}
treats the \code{SEXP} as a resource, following the RAII (resource
acquisition is initialization) pattern. As long as the \code{RObject}
instance is alive, its underlying \code{SEXP} remains protected from garbage
collection. When the \code{RObject} goes out of scope (either via a function
return or through an exception), it removes the protection so that if the \code{SEXP} is not
otherwise protected when it becomes subject to garbage collection.

% [Dirk]: Shorten and make a footnote?
% [Romain]: yes, but the whole section needs cleaning anyway
Garbage collection is only mentioned here to illustrate the basic design
of the \code{RObject} class, the user of \pkg{Rcpp} need not to concern 
himself/herself with such matters and can instead focus on the problem
that he/she is solving.

The \code{RObject} class also defines a set of member functions that
can be used on any R object, regardless of its type.
% [Dirk]: Do we need the table if we shorten the paper?
% [Romain]: Probably not. Noth that interesting anyway.

\begin{center}
\begin{small}
\begin{tabular}{cc}
method & action \\
\hline
\code{isNULL} & is the object \code{NULL}\\
\hline
\code{attributeNames} & the names of its attributes\\
\code{hasAttribute} & does it have a given attribute\\
\code{attr} & retrieve or set an attribute \\
\hline
\code{isS4} & is it an S4 object \\
\code{hasSlot} & if S4, does it have the given slot\\
\code{slot} & retrieve a given slot \\
\hline
\end{tabular}
\end{small} 
\end{center}

\subsection{Derived classes}

Internally, an R object must have one type amongst the set of 
predefined types, commonly referred to as SEXP types. R internals
\citep{R:ints} documents the various types. \pkg{Rcpp} associates
a C++ class for most SEXP types.

% [Romain] I don't like this table anymore
% including also the description of each SEXP type would make it better
% but it then takes too much space
% 
% maybe we need some sort of UML like diagram
%
% [Dirk] To be honest I never liked it much either.  Good go into an
% Appendix, or we just pick a few key combinations and describe them in
% text. 
%
% [Romain] Please be honest, I'd rather have the comment from you than
%          from the reviewer. the text after will need some cleaning also then
% [Dirk]   I'd say cut. There is too much 'low-level' stuff here. I see the
%          paper as trying to interest a non-C/C++ programmer in trying Rcpp, 
%          This scares children and grown me alike.  Better for the 'long
%          paper' on all the juicy details.
%          But we need better context. How can we hash out what a concise and
%          and convincing section on 'New API' should look like?  Show how
%          easy the code, and make a gentle mention of some of the key C++
%          technologies?  I am open to any idea.
\begin{center}
\begin{small}
\begin{tabular}{ccc}
SEXP type &  \pkg{Rcpp} class \\
\hline 
\code{NILSXP} &  	\\
\code{SYMSXP} &	 \code{Symbol} \\
\code{LISTSXP} & \code{Pairlist} \\
\code{CLOSXP} &	 \code{Function} \\
\code{ENVSXP} &	 \code{Environment} \\
\code{PROMSXP} & \code{Promise} \\
\code{LANGSXP} & \code{Language} \\
\code{SPECIALSXP} & \code{Function} \\
\code{BUILTINSXP} & \code{Function} \\
\code{CHARSXP} & \\
\code{LGLSXP} &	 \code{LogicalVector} \\
\code{INTSXP} &	 \code{IntegerVector} \\
\code{REALSXP} & \code{NumericVector} \\
\code{CPLXSXP} & \code{ComplexVector}\\
\code{STRSXP} &	 \code{CharacterVector} \\
\code{DOTSXP} &	 \code{Pairlist} \\
\code{ANYSXP} &	 \\
\code{VECSXP} &	 \code{List} \\
\code{EXPRSXP} & \code{ExpressionVector}\\
\code{BCODESXP} & \\
\code{EXTPTRSXP} & \code{XPtr<T>}\\
\code{WEAKREFSXP} & \code{WeakReference}\\
\code{RAWSXP} &	 \code{RawVector}\\
\code{S4SXP} & \\
\hline
\end{tabular}
\end{small}
\end{center}

Some types do not have their own C++ class. \code{NILSXP} and 
\code{S4SXP} have their functionality covered by the \code{RObject}
class; \code{ANYSXP} is just a placeholder to facilitate S4 dispatch 
(and no object in R has this type); and \code{BCODESXP} is not currently 
used.

Each class contains functionality that is relevant to the R object
that it encapsulates. For example \code{Environment} contains 
member methods to query the list of objects in the associated environment, 
classes with the \code{Vector} overload the \code{operator[]} in order
to extract/modify values at the given position in the vector, ...

The rest of this section presents example uses of \pkg{Rcpp} classes. 

\subsection{numeric vector}

The following code snippet is extracted from Writing R extensions
\citep{R:exts}. It creates a \code{numeric} vector of two elements 
and assigns some values to it. 

\begin{example}
SEXP ab;
PROTECT(ab = allocVector(REALSXP, 2));
REAL(ab)[0] = 123.45;
REAL(ab)[1] = 67.89;
UNPROTECT(1);
\end{example}

Although this is one of the simplest examples in Writing R extensions, 
it seems verbose and it is not trivial at first sight what is happening.
\begin{itemize}
\item \code{allocVector} is used to allocate memory. We must supply to it 
the type of data (\code{REALSXP}) and the number of elements.
\item once allocated, the \code{ab} object must be protected from
garbage collection. Since the garbage collector can happen at any time, 
not protecting an object means its memory might be reclaimed before we are
finished with it.
\item The \code{REAL} macro returns a pointer to the beginning of the 
actual array; its indexing is does not resemble either R or C++.
\end{itemize}

Using the \code{Rcpp::NumericVector}, the code can be rewritten: 


\begin{example}
Rcpp::NumericVector ab(2) ;
ab[0] = 123.45;
ab[1] = 67.89;
\end{example}

The code contains much less idiomatic decorations. Here are the steps involved: 
\begin{itemize}
\item The \code{NumericVector} constructor is given the number
of elements the vector contains (2), this hides a call to the 
\code{allocVector} we saw previously. 
\item Also hidden is protection of the 
object from garbage collection, which is a behavior that \code{NumericVector}
inherits from \code{RObject}
\item values are assigned to the first and second elements of the vector. 
This is achieved \code{NumericVector} overloads the \code{operator[]}.
\end{itemize}

With the most recent compilers (e.g. G++ >= 4.4) which already implement
parts of the forthcoming C++ standard (C++0x), the preceding code may even be
reduced to this:

\begin{example}
Rcpp::NumericVector ab = \{123.45, 67.89\};
\end{example}

\subsection{character vectors}

A second example deals with character vectors and emulates this R code

\begin{example}
> x <- c("foo", "bar")
\end{example}

Using the traditional R API, the vector can be allocated and filled as such:

\begin{example}
SEXP ab;
PROTECT(ab = allocVector(STRSXP, 2));
SET_STRING_ELT( ab, 0, mkChar("foo") );
SET_STRING_ELT( ab, 1, mkChar("bar") );
UNPROTECT(1);
\end{example}

Using the \pkg{Rcpp::CharacterVector} class, we can express this code as : 

\begin{example}
CharacterVector ab(2) ;
ab[0] = "foo" ;
ab[1] = "bar" ;
\end{example}

Additionally, if C++0x initializer list is implemented by the compiler, the 
code can be trimmed to the essential :

\begin{example}
CharacterVector ab = \{"foo","bar"\};
\end{example}


\section{wrap and as}

Besides classes, the \pkg{Rcpp} package also contains utilities allowing
conversion from R objects to C++ types and vice-versa. Through 
polymorphism, the \code{wrap} set of functions can be used to wrap 
some data structure into an \code{RObject} instance. 

In total, the \pkg{Rcpp} defines 23 different \code{wrap} 
functions, including :
\begin{itemize}
\item SEXP
\item primitive types : \code{bool}, \code{int}, \code{double}, 
\code{size\_t}, \code{unsigned char} (byte), \code{std::string} and
\code{char*}
\item STL vectors of these types: \code{vecor<int>},
\code{vector<double>}, \code{vector<bool>}, \code{vector<unsigned char>}, 
\code{vector<string>}
\item STL sets : \code{set<int>}, \code{set<double>}, \code{set<unsigned char>}, 
\code{set<string>}
\item initializer lists (only available in G++ 4.4 or later).
\end{itemize}

Each type is wrapped in the most sensible class, e.g. \code{vector<double>}
is wrapped into an \pkg{NumericVector} object, which in turns encapsulates
a numeric vector (a \code{SEXP} of type \code{REALSXP}). 
Here are a few examples of \code{wrap} calls: 

\begin{example}
LogicalVector x1 = wrap( false ); 
IntegerVector x2 = wrap( 1 ) ;    

vector<double> v ; 
v.push_back(0.0); v.push_back( 1.0 ); 
NumericVector x3 = wrap( v ) ;  

// initializer list (only on GCC >= 4.4)
LogicalVector x4 = wrap( \{ false, true\} );
CharacterVector x5 = wrap( \{"foo", "bar"\} );
\end{example}

Similarly, converting an R object to a C++ standard type is implemented
by variations on the \code{as} template function. In this case, we must 
use the angle brackets to specify which version of as we want to use. 

\begin{example}
bool x = as<bool>(x) ;
double x = as<double>(x) ;
vector<int> x = as< vector<int> >(x) ;
\end{example}

\section{external pointers}

In addition to primitive data types, R can handle arbitrary pointers
by encapsulating the pointer in a special R object, the external 
pointer. \cite{R:exts} documents the available API R has to offer to 
deal with external pointers. 

\pkg{Rcpp} takes advantage of C++ templates and smart pointers and 
defines the templated class \code{XPtr} that acts as a smart 
pointer to the underlying C++ object. 

Assuming we get from R an external pointer to a \code{std::vector<int>}
c++ object, we can manipulate it as such using the \code{XPtr} class:

\begin{example}
// xp is an external pointer 
// to a std::vector<int>
XPtr< std::vector<int> > p(xp) ;
p->push\_back(1) ;
p->push\_back(2) ;
p->size() ; 
\end{example}

The \code{XPtr} class directly derives from the \code{RObject} class.
Thanks to its template parameter and overloading of the \code{->} 
and \code{*} operators, objects of the \code{XPtr<Foo>} generated
class look and feel like raw pointers (\code{Foo*}).

Making an external pointer from a raw pointer is equally easy using 
another constructor. 

\begin{example}
std::vector<int> *pv = new std::vector<int> ;
XPtr< std::vector<int> > p(pv,true) ;
\end{example}

The creation of the instance of the \code{XPtr< std::vector<int> >} 
smart extenal pointer to a \code{std::vector<int>} hides the 
R API that is typically used for external pointers, including registration
of a finalizer to be executed to free the memory of the vector when the
external pointer goes out of scope. 

\section{other examples}

The last example shows how to use \pkg{Rcpp} to emulate the R code below.
For more examples, the reader is invited to 
refer to the comprehensive documentation included in \pkg{Rcpp}
as well as the many examples that the package contains as part of 
its unit tests. 

\begin{example}
> rnorm( 10L, sd = 100.0 )
\end{example}

The code can be expressed in several ways in \pkg{Rcpp}, the first version
shows the use of the \code{Environment} and \code{Function} classes. 

\begin{example}
Environment stats("package:stats") ;
Function rnorm = stats.get("rnorm") ;
return rnorm(10, Named("sd", 100.0) ) ;
\end{example}

We first pull out the \code{rnorm} function from the environment 
called \samp{package:stats} in the search path, then call the function
using syntax similar to calling the function in R. The \code{Named} 
class is an utility class that helps emulating the use of 
named arguments.

The second version shows the use of the \code{Language} class, which 
manage calls (LANGSXP). 

\begin{example}
Language call("rnorm", 10, Named("sd", 100 ) ) ;
call.eval() ;
\end{example}

In this version, we first create a call to the symbol "rnorm" and
evaluate the call in the global environment, this is similar to the 
R code : 

\begin{example}
> eval( call( "rnorm", 10L, sd = 100 ) )
\end{example}

Using the R API, the first example, using the actual
\code{rnorm} function,
translates to :

\begin{example}
SEXP stats = PROTECT( 
\ \ R_FindNamespace( mkString("stats") ) ) ;
SEXP rnorm = PROTECT( 
\ \ findVarInFrame( stats, install("rnorm") ) ) ;
SEXP call  = PROTECT( 
\ \ LCONS( rnorm, 
\ \ \ \ CONS(ScalarInteger(10), 
\ \ \ \ \ \ CONS(ScalarReal(100.0), R_NilValue)))) ;
SET_TAG( CDDR(call), install("sd") ) ;
SEXP res = PROTECT( eval( call, R_GlobalEnv ) );
UNPROTECT(4) ;
return res ;
\end{example}

and the second example, using the \samp{rnorm} symbol, and therefore
involving implicit lookup in hte search path, can be written as:

\begin{example}
SEXP call  = PROTECT( 
\ \ LCONS( install("rnorm"), 
\ \ \ \ CONS(ScalarInteger(10), 
\ \ \ \ \ \ CONS(ScalarReal(100.0), R_NilValue)))) ;
SET_TAG( CDDR(call), install("sd") ) ;
SEXP res = PROTECT( eval( call, R_GlobalEnv ) );
UNPROTECT(2) ;
return res ;
\end{example}


\section{Performance/Limitations}

In this section, we illustrate that C++ features come with a price
in terms of performance. As users of \pkg{Rcpp}, we do not want
to replace performance with comfort. 

As part of the redesign of \pkg{Rcpp}, data copy is kept to the
absolute minimum, the \code{RObject} class and all its derived
classes are just a container for a \code{SEXP}, we let R perform
all memory management and access data though the macros or functions
offered by the standard R API. In contrasts, some data structures
of the classic \pkg{Rcpp} interface such as the templated 
\code{RcppVector} used containers offered by the standard template
library to hold the data, requiring copy of the data 
from R to C++ and back.

In this section, we illustrate how to take advantage of \code{Rcpp} to get
the best of it. The classic Rcpp translation of the convolve example from
\cite{R:exts} appears in section~\ref{sec:classic_rcpp}.  With the new API,
the code can be written as shown below. The main difference is that the input
parameters are directly passed to types \code{Rcpp::NumericVector}, and that
the return vector is automatically converted to a \code{SEXP} type.

\begin{example}
#include <Rcpp.h>

RcppExport SEXP convolve3cpp(SEXP a, SEXP b)\{
    Rcpp::NumericVector xa(a);
    Rcpp::NumericVector xb(b);
    int n_xa = xa.size() ;
    int n_xb = xb.size() ;
    int nab = n_xa + n_xb - 1;
    Rcpp::NumericVector xab(nab);

    for (int i = 0; i < nab; i++) xab[i] = 0.0;
    for (int i = 0; i < n_xa; i++)
        for (int j = 0; j < n_xb; j++) 
            xab[i + j] += xa[i] * xa[j];

    return xab ;
\}
\end{example}

Seemingly, this code is as efficient as it can be. 
However, when considering the implementation of the \code{operator[]}
for the \code{NumericVector} class: 

% FIXME: not the case anymore, this has been optimized by caching the 
%        pointer inside the NumericVector. This needs update

\begin{example}
inline double& operator[]( const int& i ) { 
	return REAL(m_sexp)[i];
}
\end{example}

Each call to the \code{operator[]} on a \code{NumericVector}
calls the \code{REAL} macro of the R API to retrieve the pointer to the
underlying array of \code{double}. The code in \cite{R:exts} is much 
more parsimonious with exactly only 3 calls to the \code{REAL} macro, 
delegating extraction to pointer arithmetics which are usually much more 
efficient. 

The \code{NumericVector} class provides two member functions \code{begin}
and \code{end} that can use used to retrieve respectively 
the pointer to the first element and to the element after the last element
of the underlying array. We can revisit the code to take advantage
of \code{begin} : 

\begin{example}
#include <Rcpp.h>

RcppExport SEXP convolve4cpp(SEXP a, SEXP b) \{
    Rcpp::NumericVector xa(a);
    Rcpp::NumericVector xb(b);
    int n_xa = xa.size() ;
    int n_xb = xb.size() ;
    int nab = n_xa + n_xb - 1;
    Rcpp::NumericVector xab(nab);
    
    double* pa = xa.begin() ;
    double* pb = xb.begin() ;
    double* pab = xab.begin() ;
    int i,j=0; 
    for (i = 0; i < nab; i++) pab[i] = 0.0;
    for (i = 0; i < n_xa; i++)
        for (j = 0; j < n_xb; j++) 
            pab[i + j] += pa[i] * pb[j];

    return xab ;
\}
\end{example}

The following timings show the time taken (in milliseconds) 
by 1000 replicates of each function with \code{a} and 
\code{b} containing 100 elements.

\begin{center}
\begin{tabular}{cc}
Method & elapsed time (ms) \\ 
\hline
R API & 34 \\
\code{RcppVector<double>} & 353 \\
\code{NumericVector::operator[]} & 55 \\
\code{NumericVector::begin} & 36 \\
\hline
\end{tabular}
\end{center}

\section{Summary}

% The \code{Rcpp} package provides comprehensive set of C++
% classes aimed at significantly reducing the complexity and
% discipline involved in combining R with compiled code.
% 
% By assuming the responsibility of protection against garbage
% collection automatically and transparently and encapsulating R objects
% in C++ classes, \pkg{Rcpp} empowers the developper to concentrate on 
% the problem at hand instead of manually keeping track of 
% the \code{PROTECT}/\code{UNPROTECT} dance and without requiring 
% the expertise of knowing the details of the many macros and functions
% of the R internal API.
% 
% Evidently, C++ has a price and we have shown how to take advantage
% of \code{Rcpp} to reduce --- if not eliminate --- the overhead while
% significantly improving code clarity and maintainability. 


\bibliography{EddelbuettelFrancois}

\address{Dirk Eddelbuettel\\
  Debian Project\\
  Chicago, IL\\
  USA}\\
\email{edd@debian.org}

\address{Romain Fran\c{c}ois\\
  Professionnal R Enthusiast\\
  3 rue Emile Bonnet, 34 090 Montpellier\\
  FRANCE}\\
\email{francoisromain@free.fr}

