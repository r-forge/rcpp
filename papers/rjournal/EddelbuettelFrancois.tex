%% Emacs please consider this:  -*- mode: latex; TeX-master: "RJwrapper.tex"; -*-

\title{Rcpp: Seamless R and C++ integration}
\author{by Dirk Eddelbuettel and Romain Franc\c{c}ois}

\maketitle

\abstract{The \pkg{Rcpp} package dramatically simplifies the 
process of integrating C++ code with R. It provides a
consistent C++ class hierarchy that maps various types of 
R objects (vectors, functions, environments, ...) to 
dedicated C++ classes. Data interchange between R and C++
is managed by simple, flexible and extensible concepts.
\pkg{Rcpp} substantially lowers the language barrier for programmers
wanting to combine compiled code with R.}

\section{Introduction} 

R is an extensible system. The 'Writing R Extensions' manual \citep{R:exts}
describes in detail the ways to augment R with compiled code,
focussing mostly on C code. The R API described in Writing R Extensions is
based on a set of functions and macros operating on \code{SEXP}, the internal
representation of R objects.

% appendix A of Chambers's software for data analysis ?
In this article, we discuss the functionality of the \pkg{Rcpp}
package, which we believe simplifies dramatically the usage of C++ code
in R. Combining R and C++ is not a new idea, so we start with
a short review of other approaches and give some historical
background on the development of \pkg{Rcpp}.

The current version of \pkg{Rcpp} combines two distincts
APIs. The first---which we call `classic \pkg{Rcpp} API'---exists since 
the first version of \pkg{Rcpp}. The second API, enclosed in the 
\code{Rcpp} C++ namespace is a newer codebase which we started to develop
more recently. This article 
% mostly concerns the newer API, and  %% [Dirk] Really?
% [Romain] based on relative lengths of coverage ... 
highlights some of the key design and implementation choices: 
lightweight encapsulation of R object in C++ classes, automatic
garbage collection strategy, code inlining, data interchange between 
R and C++ and error handling. 

Several examples are included to 
illustrate the advantage of using \pkg{Rcpp} as opposed to 
the traditional R API and many more examples are available within 
the package. 

%\section{Background}

\subsection{Historical Context}

\pkg{Rcpp} first appeared in 2005 as a contribution to the \pkg{RQuantLib}
package \citep{eddelbuettelkhan09:rquantlib} before becoming a CRAN
package in early 2006. Several releases followed in quick succession; all of
these were under the name \pkg{Rcpp}. The package was then renamed to
\pkg{RcppTemplate} and several more releases followed during 2006 under the
new name.  However, no new releases or updates were made during 2007, 2008
and most of 2009.

Given the continued use of the package, we revived it using the former name
\pkg{Rcpp}. New releases started in November 2008 which include an improved
build and distribution process, additional documentation, and new
functionality---while retaining the existing interface.  This constitutes the
`classic \pkg{Rcpp}' interface (described in the next section)
which will be maintained for the forseeable future.

Yet C++ coding standards continued to evolve. So starting in 2009 the
codebase was significantly extended and numerous new features were added.
Several of these are described below in the section on the the `new
\pkg{Rcpp}' interface. This new API is our current focus, and we intend to
both extend and support it going forward.

\subsection{Comparison}

Integration of C++ and R has been addressed by several authors; the earliest
published reference is probably \cite{batesdebroy01:cppclasses}.
An unpublished paper by \cite{javagailemanly07:r_cpp} expresses several ideas
that are close to some of our approaches, though not yet fully fleshed out.
%
The \pkg{Rserve} package \citep{cran:Rserve} was another early approach,
going back to 2002. On the server side, \pkg{Rserve} translates R data
structures into a binary serialization format and uses TCP/IP for
transfer. On the client side, objects are reconstructed as instances of Java
or C++ classes that emulate the structure of R objects. 

The packages \pkg{rcppbind} \citep{liang08:rcppbind}, \pkg{RAbstraction}
\citep{armstrong09:RAbstraction} and \pkg{RObjects}
\citep{armstrong09:RObjects} are all implemented using C++ templates.
However, neither one has matured to the point of a CRAN release and it
unclear how much usage these packages are seeing beyond their own authors.
%
CXXR \citep{runnalls09:cxxr} comes to this topic from the other side: 
its aim is to completely refactor R on a stronger C++ foundation. 
CXXR is therefore concerned with all aspects of the R interpreter,
REPL loop, threading---and object interchange between R and C++ is but one part.
%
Another slightly different angle is offered by
\cite{templelang09:rgcctranslationunit} who uses compiler output for
references on the code in order to add bindings and wrappers.
%
Lastly, the \pkg{RcppTemplate} package \citep{samperi09:rcpptemplate}
recently introduced a few new ideas yet decided to break with the
`classic \pkg{Rcpp}' API.

A critical comparison of these packages that addresses relevant aspects such
API features, performance, useability and documentation would be a welcome
addition to the literature, but is beyond the scope of this article.

\section{Classic Rcpp API}
\label{sec:classic_rcpp}

The core focus of \pkg{Rcpp}---particularly for the earlier API described in
this section---has always been on allowing the programmer to add C++-based
functions. We use this term in the standard mathematical sense of providing
results (output) given a set of parameters or data (input). This was
facilitated from the earliest releases using C++ classes for receiving
various types of R objects, converting them to C++ objects and allowing the
programmer to return the results to R with relative use. 

This API therefore supports two typical use cases. First, one can think of
replacing existing R code with equivalent C++ code in order to reap
performance gains.  This case is conceptually easy as there may not be
(built- or run-time) dependencies on other C or C++ libraries.  It typically
involves setting up data and parameters---the right-hand side components of a
function call---before making the call in order to provide the result that is
to be assigned to the left-hand side. Second, \pkg{Rcpp} facilitates calling
functions provided by other libraries. The use resembles the first case: data
and parameters are passed via \pkg{Rcpp} to a function set-up to call code
from an external library.  

An illustration can be provided using the time-tested example of a
convolution of two vectors. This example is shown in sections 5.2 (for the
\code{.C()} interface) and 5.9 (for the \code{.Call()} interface) of 'Writing
R Extensions' \citep{R:exts}. We have rewritten it here using classes of the
classic \pkg{Rcpp} API:

\begin{example}
#include <Rcpp.h>

RcppExport SEXP convolve2cpp(SEXP a, SEXP b) \{
  RcppVector<double> xa(a);
  RcppVector<double> xb(b);
  int nab = xa.size() + xb.size() - 1;

  RcppVector<double> xab(nab);
  for (int i = 0; i < nab; i++) xab(i) = 0.0;

  for (int i = 0; i < xa.size(); i++)
    for (int j = 0; j < xb.size(); j++) 
       xab(i + j) += xa(i) * xb(j);

  RcppResultSet rs;
  rs.add("ab", xab);
  return rs.getReturnList();
\}
\end{example}

We can highlight several aspects. First, only a single header file
\code{Rcpp.h} is needed to use the \pkg{Rcpp} API.  Second, given two
\code{SEXP} types, a third is returned.
Third, both inputs are converted to templated\footnote{C++ templates
allow functions or classes to be written somewhat independently from the 
template parameter. The actual class is instantiated by the compiler
by replacing occurences of the templated parameter(s).}
C++ vector types, here a standard \code{double}
type is used to create a vector of doubles from the template type.
Fourth, the usefulness of these classes can be seen when we query the
vectors directly for their size---using the \code{size()} member function---in
order to reserved a new result type of appropriate length whereas use based
on C arrays would have required additional parameters for the length of
vectors $a$ and $b$, leaving open the possibility of mismatches between the
actual length and the length reported by the programmer. 
Fifth, the computation itself is straightforward embedded looping just as in the
original examples in the 'Writing R Extensions' manual \citep{R:exts}.
Sixth, a return type (\code{RcppResultSet}) is prepared as a named
object which is then
converted to a list object that is returned.  We should note that the
\code{RcppResultSet} permits the return of numerous (named) objects which can
also be of different types.

We argue that this usage is already much easier to read, write and debug than the
C macro-based approach supported by R itself. Possible performance issues and
other potential limitations will be discussed throughout the article and
reviewed at the end.

\section{New \pkg{Rcpp} API}
\label{sec:new_rcpp}

More recently, the \pkg{Rcpp} API has been dramatically extended, leading to a 
complete redesign, based on the usage experience of several 
years of \pkg{Rcpp} deployment, needs from other projects, knowledge 
of the internal R API, as well as current C++ design approaches. 

\subsection{Rcpp Class hierarchy}

The \code{Rcpp::RObject} class is the basic class of the new \pkg{Rcpp} API. 
An instance of the \code{RObject} class encapsulates an R object
(\code{SEXP}), exposes methods that are appropriate for all types 
of objects and transparently manages garbage collection.

The most important aspect of the \code{RObject} class is that it is 
a very thin wrapper around the \code{SEXP} it encapsulates. The 
\code{SEXP} is indeed the only data member of an \code{RObject}. The 
\code{RObject} class does not interfere with the way R manages its 
memory, does not perform copies of the object into a suboptimal 
C++ representation, but instead merely acts as a proxy to the 
object it encapsulates so that methods applied to the \code{RObject}
instance are relayed back to the \code{SEXP} in terms of the standard
R API.

The \code{RObject} class takes advantage of the explicit life cycle of 
C++ objects to manage exposure of the underlying R object to the 
garbage collector. The \code{RObject} effectively treats 
its underlying \code{SEXP} as a resource.
The constructor of the \code{RObject} class takes 
the necessary measures to guarantee that the underlying \code{SEXP}
is protected from the garbage collector, and the destructor
assumes the responsability to withdraw that protection. 

By assuming the entire responsability of garbage collection, \code{Rcpp}
relieves the programmer from writing boiler plate code to manage
the protection stack with \code{PROTECT} and \code{UNPROTECT} macros.

The \code{RObject} class defines a set of member functions that
can be used on any R object, regardless of its type. The member
functions \code{isNULL}, \code{isObject} and \code{isS4} can be 
used to query properties of the object. 

Regarding attributes, the member functions 
\code{attributeNames} can be used to retrieve the names of the attributes, 
the \code{hasAttribute} can be used to query the existence of an attribute and 
the \code{attr} can be used to either get the current value of an 
attribute, or set the value to some other object.

Similarly, the member functions \code{hasSlot} and \code{slot}
can be used to manage slots of an S4 object. These function throw 
C++ exceptions when used on objects that are not S4 objects, or when 
trying to access a slot that does not exist for a class.

\subsection{Derived classes}

Internally, an R object must have one type amongst the set of 
predefined types, commonly referred to as SEXP types. R internals
\citep{R:ints} documents these various types. 
\pkg{Rcpp} associates a dedicated C++ class for most SEXP types, 
therefore only exposes functionality that is relevant to the R object
that it encapsulates.

For example \code{Rcpp::Environment} contains 
member functions to manage objects in the associated environment. 
Similarly, classes related to vectors (\code{IntegerVector}, \code{NumericVector}, 
\code{RawVector}, \code{LogicalVector}, \code{CharacterVector}, 
\code{GenericVector} and \code{ExpressionVector}) expose functionality
to extract and set values from the vectors.

The following sub-sections present typical uses of \pkg{Rcpp} classes in
comparison with the same code expressed using functions of the R API.

\subsection{Numeric vectors}

The following code snippet is taken from Writing R extensions
\citep{R:exts}. It creates a \code{numeric} vector of two elements 
and assigns some values to it. 

\begin{example}
SEXP ab;
PROTECT(ab = allocVector(REALSXP, 2));
REAL(ab)[0] = 123.45;
REAL(ab)[1] = 67.89;
UNPROTECT(1);
\end{example}

Although this is one of the simplest examples in Writing R extensions, 
it seems verbose and it is not obvious at first sight what is happening.
Memory is allocated by \code{allocVector}; we must also supply it with
the type of data (\code{REALSXP}) and the number of elements.  Once
allocated, the \code{ab} object must be protected from garbage
collection. Since the garbage collector can happen at any time, not
protecting an object means its memory might be reclaimed before we are
finished with it. Lastly, the \code{REAL} macro returns a pointer to the
beginning of the actual array; its indexing is does not resemble either R or
C++.

Using the \code{Rcpp::NumericVector} class, the code can be rewritten: 

\begin{example}
Rcpp::NumericVector ab(2) ;
ab[0] = 123.45;
ab[1] = 67.89;
\end{example}

The code contains fewer idiomatic decorations. The \code{NumericVector}
constructor is given the number of elements the vector contains (2), this
hides a call to the \code{allocVector} we saw previously. Also hidden is
protection of the object from garbage collection, which is a behavior that
\code{NumericVector} inherits from \code{RObject}.  Values are assigned to
the first and second elements of the vector as \code{NumericVector} overloads
the \code{operator[]}.

With the most recent compilers (e.g. GNU g++ >= 4.4) which already implement
parts of the next C++ standard (C++0x) currently being drafted, the preceding
code may even be reduced to this:

\begin{example}
Rcpp::NumericVector ab = \{123.45, 67.89\};
\end{example}

\subsection{Character vectors}

A second example deals with character vectors and emulates this R code

\begin{example}
> c("foo", "bar")
\end{example}

Using the traditional R API, the vector can be allocated and filled as such:

\begin{example}
SEXP ab;
PROTECT(ab = allocVector(STRSXP, 2));
SET_STRING_ELT( ab, 0, mkChar("foo") );
SET_STRING_ELT( ab, 1, mkChar("bar") );
UNPROTECT(1);
\end{example}

This imposes on the programmer knowledge of \code{PROTECT}, \code{UNPROTECT}, 
\code{SEXP}, \code{allocVector}, \code{SET\_STRING\_ELT}, \code{mkChar}. 

Using the \pkg{Rcpp::CharacterVector} class, we can express the same
code more concisely:

\begin{example}
CharacterVector ab(2) ;
ab[0] = "foo" ;
ab[1] = "bar" ;
\end{example}

\section{R and C++ data interchange}

In addition to classes, the \pkg{Rcpp} package contains two additional
functions to perform conversion of C++ objects to R objects and back. 

\subsection{C++ to R : wrap}

The C++ to R conversion is performed by the \code{Rcpp::wrap} templated
function. It uses advanced template meta programming techniques\footnote{A
  discussion of template meta programming is beyond the scope of this
  article.}  to convert a wide and extensible set of types and classes to the
most appropriate type of R object. The signature of the \code{wrap} template
is:

\begin{example}
template <typename T> 
SEXP wrap(const T& object) ;
\end{example}

The templated function takes a reference to a `wrappable` 
object and converts this object into a \code{SEXP}, which is what R expects. 
Currently wrappable types are :
\begin{itemize}
\item primitive types, \code{int}, \code{double}, ... which are converted 
into atomic R vectors of the appropriate type;
\item \code{std::string} which are converted to R atomic character vectors;
\item STL containers such as \code{std::vector<T>} or \code{std::list<T>}, 
as long as the template parameter type \code{T} is itself wrappable;
\item STL maps which use \code{std::string} for keys 
(e.g. \code{std::map<std::string,T>}); as long as 
the type \code{T} is wrappable;
\item any type that implements implicit conversion to \code{SEXP} through the 
\code{operator SEXP()}.
\item any type for which the the \code{wrap} template is partially or fully 
specialized.
% [Romain]: should we mention RInside as an example 
% [Dirk] Example for _what_ ?
\end{itemize}

Whether an object is wrappable is resolved at compile time, and the 
dispatch of the appropriate implementation is performed by the compiler
using modern techniques of template meta programming and class traits.
The design allows composition, so for example objects of the class
\code{std::vector< std::map<std::string,int> >} are wrappable. This is 
because \code{int} is wrappable (as a primitive type), consequently 
\code{std::map<std::string,int>} is wrappable (as an STL map of 
wrappable types keyed by strings, and therefore
\code{std::vector< std::map<std::string,int> >} is wrappable (as a 
STL container of wrappable objects). The example code below
illustrates this: 

\begin{example}
std::vector< std::map<std::string,int> > v ;

std::map< std::string, int > m1 ;
m1["foo"] = 1 ; m1["bar"] = 2 ;

std::map< std::string, int > m2 ;
m2["foo"] = 1; m2["bar"] = 2; m2["bling"] = 3;

v.push_back( m1) ;
v.push_back( m2) ;

Rcpp::wrap( v ) ;
\end{example}

The code creates a list of two named vectors, equal to the list that 
can be created by the following R code. 

\begin{example}
list( c( bar = 2L, foo = 1L) , 
      c( bar = 2L, bling = 3L, foo = 1L) )
\end{example}

\subsection{R to C++ : as}

The reversed conversion is implemented by variations of the 
\code{Rcpp::as} template. It offers less flexibility and currently
handles conversion of R objects into primitive types (bool, int, std::string, ...), 
STL vectors of primitive types  (\code{std::vector<bool>}, 
\code{std::vector<double>}, etc ...) and arbitrary types that offer 
a constructor that takes a \code{SEXP}. In addition \code{as} can 
be fully or partially specialized to manage conversion of R data 
structures to third-party types.

\subsection{Implicit use of converters}

The converters offered by \code{wrap} and \code{as} provide a very 
useful framework to implement the logic of the code in terms of C++ 
data structures and then explicitely convert data back to R. 

In addition, the converters are also used implicitely
in various places in the \code{Rcpp} API. 
Consider the following code that uses the \code{Rcpp::Environment} class to 
interchange data between C++ and R.

\begin{example}
# assuming the global environment contains 
# a variable 'x' that is a numeric vector
Rcpp::Environment global = 
\ \ \ \ Rcpp::Environment::global_env()

# extract a std::vector<double> from 
# the global environment
std::vector<double> vx = global["x"] ;

# create a map<string,string>
std::map<std::string,std::string> map ;
map["foo"] = "oof" ;
map["bar"] = "rab" ;

# push the STL map to R
global["y"] = map ;
\end{example}

In the first part of the example, the code extracts a 
\code{std::vector<double>} from the global environment. This is 
achieved by the templated \code{operator[]} of \code{Environment}
that first extracts the requested object from the environment as a \code{SEXP}, 
and then outsources to \code{Rcpp::as} the creation of the 
requested type. 

In the second part of the example, the \code{operator[]} 
delegates to wrap the production of an R object based on the 
type that is passed in (\code{std::map<std::string,std::string>}), 
and then assigns the object to the requested name.

The same mechanism is used throughout the API. Examples include access/modification
of object attributes, slots, elements of generic vectors (lists), 
function arguments, nodes of dotted pair lists and language calls and more. 

\section{Function calls}

The last example shows how to use \pkg{Rcpp} to emulate the R code below.

\begin{example}
> rnorm( 10L, sd = 100.0 )
\end{example}

The code can be expressed in several ways in \pkg{Rcpp}, the first version
shows the use of the \code{Environment} and \code{Function} classes
\footnote{We have removed the \code{Rcpp::} prefix from the following
  examples for readability; this corresponds to adding a statement
  \texttt{using namespace Rcpp;} in the code}.

\begin{example}
Environment stats("package:stats");
Function rnorm = stats.get("rnorm");
return rnorm(10, Named("sd", 100.0) );
\end{example}

We first pull out the \code{rnorm} function from the environment 
called \samp{package:stats} in the search path, then simply call the function 
using syntax similar to calling the function in R. The \code{Rcpp::Named} 
class is an utility class that is used to emulate named arguments.

The second version shows the use of the \code{Language} class, which 
manage calls (LANGSXP). 

\begin{example}
Language call("rnorm", 10, Named("sd", 100 ));
call.eval();
\end{example}

In this version, we first create a call to the symbol "rnorm" and
evaluate the call in the global environment. In both cases, \code{wrap}
is used implicitely to convert \code{10} and \code{100} 
into R integer vectors. It should be noted that this 
version involves a potentially expensive implicit lookup in the search path
to find the \code{rnorm} function. 
% should we quote luke's : http://www.cs.uiowa.edu/~luke/R/bytecode.html

For comparison, using the standard R API, the first example using the actual \code{rnorm} function
translates to :

\begin{example}
SEXP stats = PROTECT( 
\ \ R_FindNamespace( mkString("stats") ) );
SEXP rnorm = PROTECT( 
\ \ findVarInFrame( stats, install("rnorm") ) );
SEXP call  = PROTECT( 
\ \ LCONS( rnorm, 
\ \ \ \ CONS(ScalarInteger(10), 
\ \ \ \ \ \ CONS(ScalarReal(100.0), R_NilValue))));
SET_TAG( CDDR(call), install("sd") );
SEXP res = PROTECT( eval( call, R_GlobalEnv));
UNPROTECT(4) ;
return res ;
\end{example}

and the second example, using the \samp{rnorm} symbol, can be written as:

\begin{example}
SEXP call  = PROTECT( 
\ \ LCONS( install("rnorm"), 
\ \ \ \ CONS(ScalarInteger(10), 
\ \ \ \ \ \ CONS(ScalarReal(100.0), R_NilValue))));
SET_TAG( CDDR(call), install("sd") ) ;
SEXP res = PROTECT( eval( call, R_GlobalEnv));
UNPROTECT(2) ;
return res ;
\end{example}

showing that the \pkg{Rcpp} API permits us to work with code that is easier
to read, write and maintain. More examples are available as part of the documentation
included in the \pkg{Rcpp} package, as well as among its over one hundred and
fifty unit tests.

\section{Using code `inline'}
\label{sec:inline}

Extending R with compiled code also needs to address how to reliably compile,
link and load the code.  While using a package is preferable in the long run,
it may be too heavy a framework for quick explorations.  An alternative is
provided by the \pkg{inline} package \citep{cran:inline} which compiles,
links and loads a C, C++ or Fortran function---directly from the R prompt
using a simple function \code{cfunction}.  It was recently extended to work
with \pkg{Rcpp} by allowing for the use of additional header files and
libraries. This works particularly well with the \pkg{Rcpp} package where
headers and the library are automatically found if the appropriate option
\code{Rcpp} to \texttt{cfunction} is set to \code{TRUE}.

The use of \pkg{inline} is possible as \pkg{Rcpp} can be installed and
updated just like any other R package using \textsl{e.g.} the
\code{install.packages()} function for initial installation as well as
\code{update.packages()} for upgrades.  So even though R / C++ interfacing
would otherwise require source code, the \pkg{Rcpp} library is always provided
ready for use as a pre-built library through the CRAN package
mechanism.\footnote{This presumes a platform for which prebuild binaries a
  provided. \pkg{Rcpp} is available in binary form for Windows and OS X users from
  CRAN, and a \code{.deb} package for Debian and Ubuntu users. For other systems, the
  \pkg{Rcpp} library is automatically built from source during installation
  or upgrades.}

The library and header files provided by \pkg{Rcpp} for use by other packages
are installed along with the \pkg{Rcpp} package making it possible for
\pkg{Rcpp} to provide the appropriate \code{-I} and \code{-L} switches needed
for compilation and linking.  So internally, \pkg{inline} makes uses of the
two functions \code{Rcpp:::CxxFlags()} and \code{Rcpp:::LdFlags()} that
provide this information (and which are also used by \code{Makevars} files of
other packages).  Here, however, all this is done behind the scenes and the
user need not worry about compiler or linker options or settings.

The convolution example provided above can be rewritten for use by
\pkg{inline} as shown below.  The function body is provided by the character
variable \code{src}, the function header is defined by the argument
\code{signature}---and we only need to enable \code{Rcpp=TRUE} to obtain a
new function \code{fun} based on the C++ code in \code{src} where we also
switched from the classic \pkg{Rcpp} API to the new one:

\begin{example}
src <- '
  Rcpp::NumericVector xa(a);
  Rcpp::NumericVector xb(b);
  int n_xa = xa.size(), n_xb = xb.size();

  Rcpp::NumericVector xab(n_xa + n_xb - 1);

  for (int i = 0; i < n_xa; i++)
    for (int j = 0; j < n_xb; j++)
       xab[i + j] += xa[i] * xb[j];

  return xab;
'
fun <- cfunction( 
	signature(a="numeric", b="numeric"), 
	src, Rcpp=TRUE)
\end{example}

The main difference to the previous solution is that the input parameters are
directly passed to types \code{Rcpp::NumericVector}, and that the return
vector is automatically converted to a \code{SEXP} type through implicit
conversion. Also in this version, the vector \code{xab} is not 
initialized because the constructor already performs initialization
to match the behaviour of the R function \code{numeric}.

\section{Error handling}

Code that uses both R and C++ has to deal with two concurrent
error handling models. \pkg{Rcpp} simplifies this and allows both 
systems to work together.

\subsection{C++ exceptions in R}

The traditional way of dealing with C++ exceptions in R is to
catch the C++ exception through the explicit try/catch blocks and
convert this exception to an R error. 

In C++, when an application throws an exception that is not caught, 
a special function (called the terminate handler) is invoked. This typically causes 
the program to abort. \pkg{Rcpp} takes advantage of this mechanism
and sets its own terminate handler which translates the C++
exception into an R condition and throws this condition so that it can 
be caught in R. The following code gives an illustration. 

\begin{example}
> fun <- cfunction( signature( x = "integer" ), 
+ ' 
+   int dx = as<int>(x) ;
+   if( dx > 10 ) 
+      throw std::range_error("too big") ;
+   return wrap(dx*dx) ;
+ ', Rcpp = TRUE, 
+  includes = "using namespace Rcpp;" )
> tryCatch( fun(12), 
+ "std::range_error" = function(e){
+    writeLines( conditionMessage(e) )
+ } )
too big
\end{example}

\subsection{R error in C++}

R currently does not offer C-level mechanisms to deal with errors. To 
overcome this problem, \pkg{Rcpp} uses the \code{Rcpp::Evaluator}
class to evaluate en expression with an R-level \code{tryCatch}
block. The error, if any, that occurs while evaluating the 
function is then translated in terms of an C++ exception. 

% example ?
% [Dirk] We're running out of space.  In the JSS piece...

\section{Performance and Limitations}

In this section, we illustrate how C++ features may well come with a price
in terms of performance. However, as users of \pkg{Rcpp}, we do not need to
substitute performance with ease of use.

As part of the redesign of \pkg{Rcpp}, data copy is kept to the
absolute minimum. The \code{RObject} class and all its derived
classes are just a container for a \code{SEXP}. We let R perform
all memory management and access data though the macros or functions
offered by the standard R API. In contrast, some data structures
of the classic \pkg{Rcpp} interface such as the templated 
\code{RcppVector} used containers offered by the standard template
library to hold the data, requiring explicit copies of the data 
from R to C++ and back.

In this section, we illustrate how to take advantage of \code{Rcpp} to get
the best of both worlds. The classic \pkg{Rcpp} translation of the convolve example from
\cite{R:exts} appears twice above where the second example showed the use
with the new API.
% [Dirk] Seemingly, no \ref with the RJournal style

The implementation of the \code{operator[]} is designed as 
efficiently as possible, using both inlining and caching, 
but even this implementation is still less efficient than the 
reference C imlementation described in \cite{R:exts}.

In order to achieve maximum efficiency, the reference implementation
extracts the underlying array pointer \code{double*} and works 
with pointer arithmetics, which is a built-in operation as opposed to 
calling the \code{operator[]} on a user-defined class which has to 
pay the price of object encapsulation.

Modelled after containers of the C++ standard template library, 
the \code{NumericVector} class provides two member functions \code{begin}
and \code{end} that can use used to retrieve respectively 
the pointer to the first and past-to-end elements of the underlying array.
We can revisit the code to take advantage of this feature : 

\begin{example}
#include <Rcpp.h>

RcppExport SEXP convolve4cpp(SEXP a, SEXP b) \{
    Rcpp::NumericVector xa(a);
    Rcpp::NumericVector xb(b);
    int n_xa = xa.size() ;
    int n_xb = xb.size() ;
    Rcpp::NumericVector xab(n_xa + n_xb - 1);
    
    double* pa = xa.begin() ;
    double* pb = xb.begin() ;
    double* pab = xab.begin() ;
    int i,j=0; 
    for (i = 0; i < n_xa; i++)
        for (j = 0; j < n_xb; j++) 
            pab[i + j] += pa[i] * pb[j];

    return xab ;
\}
\end{example}

We have benchmarked the various implementations using 
1000 replicates of each function with \code{a} and 
\code{b} containing 100 elements each. The timings are summarized in the 
table below:

\begin{center}
\begin{small}
\begin{tabular}{lrr}
\toprule
\textbf{Method} & \textbf{Time} (ms) & Ratio \\ 
\cmidrule(r){2-3}
R API & 34 & \\
\code{RcppVector<double>} & 353 & 10.38 \\
\code{NumericVector::operator[]} & 55 & 1.61 \\
\code{NumericVector::begin} & 36 &  1.06 \\
\bottomrule
\end{tabular}
\end{small}
\end{center}

The first implementation, using the traditional R API, unsurprisingly 
appears to be the most efficient. It takes advantage of pointer 
arithmetics and needs not to pay the price of object encapsulation. 

The last implementation comes close. Replicating the experiment
shows that the difference is not significant. 

The third implementation illustrates the price of object encapsulation
and calling an overloaded \code{operator[]} as opposed to using 
pointer arithmetics.

Finally the second implementation---from the classic \pkg{Rcpp} API---is
clearly behind in terms of efficiency. The difference is mainly 
caused by the many unnecessary copies that the \code{RcppVector<double>}
class performs. First, both objects (\code{a} and \code{b})
are copied into C++ structures (\code{xa} and \code{xb}). 
Then, the result is constructed as another \code{RcppVector<double>}
(\code{xab}) that is filled using the \code{operator()} which checks
at each access that the index is suitable for the object. Finally, \code{xab}
is converted back to an R object. 

\section{Summary}

The \code{Rcpp} package greatly simplifies integration of compiled C++ code
with R. 

The class hierarchy allows manipulation of R data structures in C++ 
using member functions and operators directly related to the type
of object being used, therefore reducing the level of expertise
required to master the various functions and macros offered by the
internal R API. The classes assume the entire 
responsability of garbage collection of objects, relieving the 
programmer from book-keeping operations with the protection stack 
and enabling him/her to focus on the underlying problem. 

Data interchange between R and C++---performed by the 
\code{wrap} and \code{as} template functions---allow the programmer
to write logic in terms of C++ data structures, facilitating use
of modern libraries such as the standard template library and its 
containers and algorithms. The \code{wrap} and \code{as} functions are extensible
by design and can be used either explicitely or implicitely throughout 
the API. 

Only using thin wrappers around \code{SEXP} objects, 
the footprint of the \code{Rcpp} API is very lightweight, and does not 
induces a significant performance price. 

Using the \code{Rcpp} API dramatically reduces the complexity 
of the code, which improves code readability and maintainability.
The redesign of \code{Rcpp} was motivated by the needs of other 
projects such as \code{RInside}  \citep{cran:rinside} for easy embedding 
of R in a C++ application and \code{RProtoBuf} \citep{cran:rprotobuf} 
that interfaces with the protocol buffer library. 
% [Dirk]  Do we really need to cite RInside and RProtoBuf?

\bibliography{EddelbuettelFrancois}

\address{Dirk Eddelbuettel\\
  Debian Project\\
  Chicago, IL\\
  USA}\\
\email{edd@debian.org}

\address{Romain Fran\c{c}ois\\
  Professionnal R Enthusiast\\
  3 rue Emile Bonnet, 34 090 Montpellier\\
  FRANCE}\\
\email{francoisromain@free.fr}

