\title{Mesh R and C++ with Rcpp}
\author{by Dirk Eddelbuettel and Romain Franc\c{c}ois}

\maketitle

\abstract{TBD}

\section{Introduction}

\subsection{Overview}
The \pkg{Rcpp} package provides a consistent and comprehensive set 
of C++ classes designed to ease coupling of C++ code
with R. The \code{RObject} class is responsible for 
protecting and releasing its encapsulated R object (\code{SEXP})
from garbage collection. The \code{wrap} set of functions allows
wrapping many C++ built-in types and data structures from the standard
template library into R objects. Similarly, the \code{as} set of 
templated functions allows conversion of R objects back into C++
types, such as \code{std::string}. With recent additions to the 
\pkg{inline} package \citep{cran:inline}, 
C++ code using the classes of the 
\pkg{Rcpp} package can be inlined, compiled, loaded and wrapped 
into an R function without leaving the R console. 
This article reviews some of the design choices of the
\pkg{Rcpp} package, in particular with respect to existing solutions
that deal with coupling R and C++ and shows several use cases.

Writing R Extensions \citep{R:exts} provides extensive 
documentation about the ways to couple R with code written in C. 
Writing such code requires both expertise and discipline from the 
programmer.

% Expertise, to learn and use efficiently 
% the set of macros offered by R headers. 
% Discipline, with a large amount of bookkeeping 
% %% FIXME:  The two sentences need a rewrite
% duties around the \code{PROTECT}/\code{UNPROTECT} dance one 
% as to master the steps. 

The \pkg{Rcpp} package makes extensive use of C++ features (encapsulation, 
constructors, destructors, operator overloading, templates) in order
to hide the complexity of the R API --- without losing its 
efficiency --- under the carpet of object orientation. In addition, 
\pkg{Rcpp} takes advantage of some features of the forthcoming \code{C++0x} 
standard, already supported by recent versions of the GCC.

\subsection{Context}

\pkg{Rcpp} was first released in 2005 as a contribution
to the \pkg{RQuantLib} package \citep{eddelbuettelkhan09:rquantlib}.
\pkg{Rcpp} was then released as a package of the same name in early 2006,
quickly followed by several releases before being renamed to
\pkg{RcppTemplate}. More releases followed during 2006 under the new name,
but no releases or updates were made during 2007, 2008 or most of 2009.

Given the continued use of the package, it was revived using the former name
\pkg{Rcpp}. New releases started in November 2008 which include an improved
build and distribution process, additional documentation, and new
functionality---while retaining the existing interface.  This constitutes the
`classic \pkg{Rcpp}' interface (described in the next section)
% \ref{sec:classic_rcpp}) 
which will be provided for the forseeable future.

Yet C++ coding standards continued to evolved. So, in late 2009 the codebase
was significantly extended and numerous new features were added.  Several of
these are described below following section %\ref{sec:new_rcpp}. 
This constitutes the `enhanced \pkg{Rcpp}' interface which we also intend to support going forward.

\subsection{Comparison}

Integration of C++ and R has been addressed by several authors starting with
\cite{batesdebroy01:cppclasses}. \cite{javagailemanly07:r_cpp}, in an
unpublished paper, express several ideas that are close to some of our
approaches, though not yet fully fleshed out.
%
The \pkg{Rserve} package \citep{cran:Rserve} was another early approach,
going back to 2002. However its focus in on provided a binary R server for a
C++ client was simply clients. That said, its C++ use also wrapped R object
internally for serialization.
% FIXME: the Rserve client does not know about SEXP, it defines
% Rexp, something that looks like SEXP, but isn't;
% R does not have to be on the client side

The packages \pkg{rppbind} \citep{liang08:rcppbind}, \pkg{RAbstraction}
\citep{armstrong09:RAbstraction} and \pkg{RObjects}
\citep{armstrong09:RObjects} are all implemented using C++ templates.
However, neither one has matured to the point of a CRAN release and it
unclear how much usage these packages are seeing beyond their own authors.

CXXR \citep{runnalls09:cxxr} comes to this topic from the other side: his aim
is to rebuild R using a stronger C++ foundation. 
% FIXME: That is a great line for an oral presentation but maybe not so much
% for the paper 
%  If moving from C to C++ is to be compared with improving someone's house, 
%  \pkg{Rcpp} is repainting the walls where CXXR rebuilds from the foundations.
% maybe we do a bit more than the walls ?
% new more comfortable furnitures ? 
The code based is therefore concerns with all aspects of the R interpreter,
REPL loop, threading --- and object interchange between R and C++ is but one part.
%
Another slightly different angle is offered by
\cite{templelang09:rgcctranslationunit} who uses compiler output for
references on the code in order to add bindings and wrappers.
%
Lastly, the \pkg{RcppTemplate} package \citep{samperi09:rcpptemplate}
recently introduced a few new ideas yet decided to decided to break with the
`classic \pkg{Rcpp}' API.

A critical comparison of these packages that addresses relevant aspects such
API features, performance, useability and documentation would be a welcome
addition to the literature.


\section{Classic Rcpp}
\label{sec:classic_rcpp}

The (at least initial) core focus of \pkg{Rcpp} has always been on allowing
the programmer to add C++-based functions---in the standard mathematical
sense of providing results (output) given a set of parameters or data
(input). This was facilitated from the earliest releases using C++ classes
for receiving various types of R objects, converting them to C++ objects and
allowing the programmer to return the results to R with relative use.

An illustration can be provided using the time-tested example of a
convolution of two vectors \citep{R:exts} but now rewritten using \pkg{Rcpp}.

\begin{example}
#include <Rcpp.h>

RcppExport SEXP convolve2cpp(SEXP a, SEXP b) \{
  RcppVector<double> xa(a);
  RcppVector<double> xb(b);
  int nab = xa.size() + xb.size() - 1;

  RcppVector<double> xab(nab);
  for (int i = 0; i < nab; i++) xab(i) = 0.0;

  for (int i = 0; i < xa.size(); i++)
    for (int j = 0; j < xb.size(); j++) 
       xab(i + j) += xa(i) * xb(j);

  RcppResultSet rs;
  rs.add("ab", xab);
  return rs.getReturnList();
\}
\end{example}

We can highlight several aspects. First, only one header file is needed.
Second, given two SEXP types---the bread-and-butter of all internal R
programming---a third is returned.  Third, both inputs are converted to
vector types that are \textsl{templated} which means that the vector can hold
different base types. Here a standard \code{double} is used. Fourth, the
usefulness off these classes can be seen when we query the vectors directly
for their size in order to reserved a new result type of appropriate length.
Fifth, the compuation itself is straightforward embedded looping just as in
the original example in the R Extensions manual \citep{R:exts}.  Sixth, a
return type is then prepared as a named object (something that should be
familiar to R programmers) which is then converted to a list object that is
returned.

We argue that this usage is already easier to read, write and debug than the
C macro-based approach supported by R itself.

\section{inline code}

Extending R with compiled code also needs to address how to reliably load the
code.  While this can be achieved directly using \code{dyn.load}, using a
package is preferable in the long run.  Another option is
provided by the \pkg{inline} package \citep{cran:inline} which compiles,
links and loads a C or C++ function---directly from the R prompt.  It was
recently extended to work with \pkg{Rcpp}.

The use of \pkg{inline} is possible as \pkg{Rcpp} can be used and
updated just like any other R package. It can be installed via
\code{install.packages()}, and new versions can be obtained via
\code{update.packages()} as it is provided as a dynamic
library.\footnote{Windows users however only obtain a static library though
  this could be changed.} The location of this library, and the associated
compiler and header arguments can be queried directly from the installed
package using the functions \code{Rcpp:::CxxFlags()} and
\code{Rcpp:::LdFlags()}.  Even while the R / C++ interfacing requires source
code, it is always provided ready for use as a pre-built library


\section{\pkg{Rcpp} C++ classes}
\label{sec:new_rcpp}

\subsection{The RObject class}

Having the discussed the `Classic Rcpp' API and its deployment, we now turn
to the `New Rcpp'.  Here, the \code{RObject} class is the base class of all
objects in the extended API of the \pkg{Rcpp} package. An \code{RObject} has only one
data member, the protected \code{SEXP} it encapsulates.  The \code{RObject}
treats the \code{SEXP} as a resource, following the RAII (resource
acquisition is initialization) pattern. As long as the \code{RObject}
instance is alive, its underlying \code{SEXP} remains protected from garbage
collection. When the \code{RObject} goes out of scope (either via a function
return or through an exception), it removes the protection so that if the \code{SEXP} is not
otherwise protected when it becomes subject to garbage collection.

% FIXME: Shorten and make a footnote?
Garbage collection is only mentioned here to illustrate the basic design
of the \code{RObject} class, the user of \pkg{Rcpp} need not to concern 
himself/herself with such matters and can instead focus on the problem
that he/she is solving.

The \code{RObject} class also defines a set of member functions that
can be used on any R object, regardless of its type.

\begin{center}
\begin{small}
\begin{tabular}{cc}
method & action \\
\hline
\code{isNULL} & is the object \code{NULL}\\
\hline
\code{attributeNames} & the names of its attributes\\
\code{hasAttribute} & does it have a given attribute\\
\code{attr} & retrieve or set an attribute \\
\hline
\code{isS4} & is it an S4 object \\
\code{hasSlot} & if S4, does it have the given slot\\
\code{slot} & retrieve a given slot \\
\hline
\end{tabular}
\end{small} 
\end{center}

\subsection{Derived classes}

Internally, an R object must have one type amongst the set of 
predefined types, commonly referred to as SEXP types. R internals
\citep{R:ints} documents the various types. \pkg{Rcpp} associates
a C++ class for most SEXP types.
        
\begin{center}
\begin{small}
\begin{tabular}{ccc}
SEXP type &  \pkg{Rcpp} class \\
\hline 
\code{NILSXP} &  	\\
\code{SYMSXP} &	 \code{Symbol} \\
\code{LISTSXP} & \code{Pairlist} \\
\code{CLOSXP} &	 \code{Function} \\
\code{ENVSXP} &	 \code{Environment} \\
\code{PROMSXP} & \code{Promise} \\
\code{LANGSXP} & \code{Language} \\
\code{SPECIALSXP} & \code{Function} \\
\code{BUILTINSXP} & \code{Function} \\
\code{CHARSXP} & \\
\code{LGLSXP} &	 \code{LogicalVector} \\
\code{INTSXP} &	 \code{IntegerVector} \\
\code{REALSXP} & \code{NumericVector} \\
\code{CPLXSXP} & \code{ComplexVector}\\
\code{STRSXP} &	 \code{CharacterVector} \\
\code{DOTSXP} &	 \code{Pairlist} \\
\code{ANYSXP} &	 \\
\code{VECSXP} &	 \code{List} \\
\code{EXPRSXP} & \code{ExpressionVector}\\
\code{BCODESXP} & \\
\code{EXTPTRSXP} & \code{XPtr<T>}\\
\code{WEAKREFSXP} & \code{WeakReference}\\
\code{RAWSXP} &	 \code{RawVector}\\
\code{S4SXP} & \\
\hline
\end{tabular}
\end{small}
\end{center}

Some types do not have their own C++ class. \code{NILSXP} and 
\code{S4SXP} have their functionality covered by the \code{RObject}
class; \code{ANYSXP} is just a placeholder to facilitate S4 dispatch 
(and no object in R has this type); and \code{BCODESXP} is not currently 
used.

Each class contains functionality that is relevant to the R object
that it encapsulates. For example \code{Environment} contains 
member methods to query the list of objects in the associated environment, 
classes with the \code{Vector} overload the \code{operator[]} in order
to extract/modify values at the given position in the vector, ...

The rest of this section presents example uses of \pkg{Rcpp} classes. 

\subsection{numeric vector}

The following code snippet is extracted from Writing R extensions
\citep{R:exts}. It creates a \code{numeric} vector of two elements 
and assigns some values to it. 

\begin{example}
#include <R.h>
#include <Rinternals.h>

SEXP ab;
....
PROTECT(ab = allocVector(REALSXP, 2));
REAL(ab)[0] = 123.45;
REAL(ab)[1] = 67.89;
UNPROTECT(1);
\end{example}

Although this is one of the simplest examples in Writing R extensions, 
it seems verbose and it is not trivial at first sight what is happening.
\begin{itemize}
\item \code{allocVector} is used to allocate memory. We must supply to it 
the type of data (\code{REALSXP}) and the number of elements.
\item once allocated, the \code{ab} object must be protected from
garbage collection. Since the garbage collector can happen at any time, 
not protecting an object means its memory might be reclaimed before we are
finished with it.
\item The \code{REAL} macro returns a pointer to the beginning of the 
actual array; its indexing is does not resemble either R or C++.
\end{itemize}

Using the \code{Rcpp::NumericVector}, the code can be rewritten: 

%#include <Rcpp.h>
%using namespace Rcpp;

\begin{example}
Rcpp::NumericVector ab(2) ;
ab[0] = 123.45;
ab[1] = 67.89;
\end{example}

The code contains much less idiomatic decorations. Here are the steps involved: 
\begin{itemize}
\item The \code{NumericVector} constructor is given the number
of elements the vector contains (2), this hides a call to the 
\code{allocVector} we saw previously. 
\item Also hidden is protection of the 
object from garbage collection, which is a behavior that \code{NumericVector}
inherits from \code{RObject}
\item values are assigned to the first and second elements of the vector. 
This is achieved \code{NumericVector} overloads the \code{operator[]}.
\end{itemize}

With the most recent compilers (e.g. G++ >= 4.4) which already implement
parts of the forthcoming C++ standard (C++0x), the preceding code may even be
reduced to this:

%#include <Rcpp.h>
%using namespace Rcpp;
\begin{example}
Rcpp::NumericVector ab = \{123.45, 67.89\};
\end{example}

\subsection{character vectors}

A second example deals with character vectors and emulates this R code

\begin{example}
> x <- c("foo", "bar")
\end{example}

Using the traditional R API, the vector can be allocated and filled as such:

\begin{example}
SEXP ab;
PROTECT(ab = allocVector(STRSXP, 2));
SET_STRING_ELT( ab, 0, mkChar("foo") );
SET_STRING_ELT( ab, 1, mkChar("bar") );
UNPROTECT(1);
\end{example}

Using the \pkg{Rcpp::CharacterVector} class, we can express this code as : 

\begin{example}
CharacterVector ab(2) ;
ab[0] = "foo" ;
ab[1] = "bar" ;
\end{example}

Additionally, if C++0x initializer list is implemented by the compiler, the 
code can be trimmed to the essential :

\begin{example}
CharacterVector ab = \{"foo","bar"\};
\end{example}


\section{wrap and as}

Besides classes, the \pkg{Rcpp} package also contains utilities allowing
conversion from R objects to C++ types and vice-versa. Through 
polymorphism, the \code{wrap} set of functions can be used to wrap 
some data structure into an \code{RObject} instance. 

In total, the \pkg{Rcpp} defines 23 different \code{wrap} 
functions, including :
\begin{itemize}
\item SEXP
\item primitive types : \code{bool}, \code{int}, \code{double}, 
\code{size\_t}, \code{unsigned char} (byte), \code{std::string} and
\code{char*}
\item STL vectors of these types: \code{vecor<int>},
\code{vector<double>}, \code{vector<bool>}, \code{vector<unsigned char>}, 
\code{vector<string>}
\item STL sets : \code{set<int>}, \code{set<double>}, \code{set<unsigned char>}, 
\code{set<string>}
\item initializer lists (only available in G++ 4.4 or later).
\end{itemize}

Each type is wrapped in the most sensible class, e.g. \code{vector<double>}
is wrapped into an \pkg{NumericVector} object, which in turns encapsulates
a numeric vector (a \code{SEXP} of type \code{REALSXP}). 
Here are a few examples of \code{wrap} calls: 

\begin{example}
LogicalVector x1 = wrap( false ); 
IntegerVector x2 = wrap( 1 ) ;    

vector<double> v ; 
v.push_back(0.0); v.push_back( 1.0 ); 
NumericVector x3 = wrap( v ) ;  

// initializer list (only on GCC >= 4.4)
LogicalVector x4 = wrap( \{ false, true\} );
CharacterVector x5 = wrap( \{"foo", "bar"\} );
\end{example}

Similarly, converting an R object to a C++ standard type is implemented
by variations on the \code{as} template function. In this case, we must 
use the angle brackets to specify which version of as we want to use. 

\begin{example}
bool x = as<bool>(x) ;
double x = as<double>(x) ;
vector<int> x = as< vector<int> >(x) ;
\end{example}

\section{external pointers}

In addition to primitive data types, R can handle arbitrary pointers
by encapsulating the pointer in a special R object, the external 
pointer. \cite{R:exts} documents the available API R has to offer to 
deal with external pointers. 

\pkg{Rcpp} takes advantage of C++ templates and smart pointers and 
defines the templated class \code{XPtr} that acts as a smart 
pointer to the underlying C++ object. 

Assuming we get from R an external pointer to a \code{std::vector<int>}
c++ object, we can manipulate it as such using the \code{XPtr} class:

\begin{example}
// xp is an external pointer 
// to a std::vector<int>
XPtr< std::vector<int> > p(xp) ;
p->push\_back(1) ;
p->push\_back(2) ;
p->size() ; 
\end{example}

The \code{XPtr} class directly derives from the \code{RObject} class.
Thanks to its template parameter and overloading of the \code{->} 
and \code{*} operators, objects of the \code{XPtr<Foo>} generated
class look and feel like raw pointers (\code{Foo*}).

Making an external pointer from a raw pointer is equally easy using 
another constructor. 

\begin{example}
std::vector<int> *pv = new std::vector<int> ;
XPtr< std::vector<int> > p(pv,true) ;
\end{example}

The creation of the instance of the \code{XPtr< std::vector<int> >} 
smart extenal pointer to a \code{std::vector<int>} hides the 
R API that is typically used for external pointers, including registration
of a finalizer to be executed to free the memory of the vector when the
external pointer goes out of scope. 

\section{other examples}

The last example shows how to use \pkg{Rcpp} to emulate the R code below.
For more examples, the reader is invited to 
refer to the comprehensive documentation included in \pkg{Rcpp}
as well as the many examples that the package contains as part of 
its unit tests. 

\begin{example}
> rnorm( 10L, sd = 100.0 )
\end{example}

The code can be expressed in several ways in \pkg{Rcpp}, the first version
shows the use of the \code{Environment} and \code{Function} classes. 

\begin{example}
Environment stats("package:stats") ;
Function rnorm = stats.get("rnorm") ;
return rnorm(10, Named("sd", 100.0) ) ;
\end{example}

We first pull out the \code{rnorm} function from the environment 
called \samp{package:stats} in the search path, then call the function
using syntax similar to calling the function in R. The \code{Named} 
class is an utility class that helps emulating the use of 
named arguments.

The second version shows the use of the \code{Language} class, which 
manage calls (LANGSXP). 

\begin{example}
Language call("rnorm", 10, Named("sd", 100 ) ) ;
call.eval() ;
\end{example}

%TODO: implement Language::eval( ) !!

In this version, we first create a call to the symbol "rnorm" and
evaluate the call in the global environment, this is similar to the 
R code : 

\begin{example}
> eval( call( "rnorm", 10L, sd = 100 ) )
\end{example}

Using the R API, the first example, using the actual
\code{rnorm} function,
translates to :

\begin{example}
SEXP stats = PROTECT( 
\ \ R_FindNamespace( mkString("stats") ) ) ;
SEXP rnorm = PROTECT( 
\ \ findVarInFrame( stats, install("rnorm") ) ) ;
SEXP call  = PROTECT( 
\ \ LCONS( rnorm, 
\ \ \ \ CONS(ScalarInteger(10), 
\ \ \ \ \ \ CONS(ScalarReal(100.0), R_NilValue)))) ;
SET_TAG( CDDR(call), install("sd") ) ;
SEXP res = PROTECT( eval( call, R_GlobalEnv ) );
UNPROTECT(4) ;
return res ;
\end{example}

and the second example, using the \samp{rnorm} symbol, and therefore
involving implicit lookup in hte search path, can be written as:

\begin{example}
SEXP call  = PROTECT( 
\ \ LCONS( install("rnorm"), 
\ \ \ \ CONS(ScalarInteger(10), 
\ \ \ \ \ \ CONS(ScalarReal(100.0), R_NilValue)))) ;
SET_TAG( CDDR(call), install("sd") ) ;
SEXP res = PROTECT( eval( call, R_GlobalEnv ) );
UNPROTECT(2) ;
return res ;
\end{example}


\section{Performance/Limitations}

In this section, we illustrate that C++ features come with a price
in terms of performance. As users of \pkg{Rcpp}, we do not want
to replace performance with comfort. 

As part of the redesign of \pkg{Rcpp}, data copy is kept to the
absolute minimum, the \code{RObject} class and all its derived
classes are just a container for a \code{SEXP}, we let R perform
all memory management and access data though the macros or functions
offered by the standard R API. In contrasts, some data structures
of the classic \pkg{Rcpp} interface such as the templated 
\code{RcppVector} used containers offered by the standard template
library to hold the data, requiring copy of the data 
from R to C++ and back.

In this section, we illustrate how to take advantage of \code{Rcpp} to get
the best of it. The classic Rcpp translation of the convolve example from
\cite{R:exts} appears in section~\ref{sec:classic_rcpp}.  With the new API,
the code can be written as shown below. The main difference is that the input
parameters are directly passed to types \code{Rcpp::NumericVector}, and that
the return vector is automatically converted to a \code{SEXP} type.

\begin{example}
#include <Rcpp.h>

RcppExport SEXP convolve3cpp(SEXP a, SEXP b)\{
    Rcpp::NumericVector xa(a);
    Rcpp::NumericVector xb(b);
    int n_xa = xa.size() ;
    int n_xb = xb.size() ;
    int nab = n_xa + n_xb - 1;
    Rcpp::NumericVector xab(nab);

    for (int i = 0; i < nab; i++) xab[i] = 0.0;
    for (int i = 0; i < n_xa; i++)
        for (int j = 0; j < n_xb; j++) 
            xab[i + j] += xa[i] * xa[j];

    return xab ;
\}
\end{example}

Seemingly, this code is as efficient as it can be. 
However, when considering the implementation of the \code{operator[]}
for the \code{NumericVector} class: 

\begin{example}
inline double& operator[]( const int& i ) { 
	return REAL(m_sexp)[i];
}
\end{example}

Each call to the \code{operator[]} on a \code{NumericVector}
calls the \code{REAL} macro of the R API to retrieve the pointer to the
underlying array of \code{double}. The code in \cite{R:exts} is much 
more parsimonious with exactly only 3 calls to the \code{REAL} macro, 
delegating extraction to pointer arithmetics which are usually much more 
efficient. 

The \code{NumericVector} class provides two member functions \code{begin}
and \code{end} that can use used to retrieve respectively 
the pointer to the first element and to the element after the last element
of the underlying array. We can revisit the code to take advantage
of \code{begin} : 

\begin{example}
#include <Rcpp.h>

RcppExport SEXP convolve4cpp(SEXP a, SEXP b) \{
    Rcpp::NumericVector xa(a);
    Rcpp::NumericVector xb(b);
    int n_xa = xa.size() ;
    int n_xb = xb.size() ;
    int nab = n_xa + n_xb - 1;
    Rcpp::NumericVector xab(nab);
    
    double* pa = xa.begin() ;
    double* pb = xb.begin() ;
    double* pab = xab.begin() ;
    int i,j=0; 
    for (i = 0; i < nab; i++) pab[i] = 0.0;
    for (i = 0; i < n_xa; i++)
        for (j = 0; j < n_xb; j++) 
            pab[i + j] += pa[i] * pb[j];

    return xab ;
\}
\end{example}

The following timings show the time taken (in milliseconds) 
by 1000 replicates of each function with \code{a} and 
\code{b} containing 100 elements.
    
\begin{center}
\begin{tabular}{cc}
Method & elapsed time (ms) \\ 
\hline
R API & 34 \\
\code{RcppVector<double>} & 353 \\
\code{NumericVector::operator[]} & 55 \\
\code{NumericVector::begin} & 36 \\
\hline
\end{tabular}
\end{center}

\section{Summary}

The \code{Rcpp} package provides comprehensive set of C++
classes aimed at significantly reducing the complexity and
discipline involved in combining R with compiled code.

By assuming the responsibility of protection against garbage
collection automatically and transparently and encapsulating R objects
in C++ classes, \pkg{Rcpp} empowers the developper to concentrate on 
the problem at hand instead of manually keeping track of 
the \code{PROTECT}/\code{UNPROTECT} dance and without requiring 
the expertise of knowing the details of the many macros and functions
of the R internal API.

Evidently, C++ has a price and we have shown how to take advantage
of \code{Rcpp} to reduce --- if not eliminate --- the overhead while
significantly improving code clarity and maintainability. 


\bibliography{EddelbuettelFrancois}

\address{Dirk Eddelbuettel\\
  Debian Project\\
  Chicago, IL\\
  USA}\\
\email{edd@debian.org}

\address{Romain Fran\c{c}ois\\
  Professionnal R Enthusiast\\
  3 rue Emile Bonnet, 34 090 Montpellier\\
  FRANCE}\\
\email{francoisromain@free.fr}

